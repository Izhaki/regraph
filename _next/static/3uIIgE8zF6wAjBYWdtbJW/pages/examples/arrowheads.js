(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{"1Ldg":function(t,e,n){"use strict";e.a=function(t){return{x:t.x+t.width/2,y:t.y+t.height/2}}},"1VIh":function(t,e,n){"use strict";var s=n("Rbzu"),r=n("hCWT"),i=n("K4BZ"),a=n("FBSb"),o=n("g2Zv"),c=function(t,e){return t.connections.map(function(n){if(function(t){var e=t.src,n=t.dst;return!Object(o.a)(e)||!Object(o.a)(n)}(n)){var r=e(t,n);if(!Object(a.a)(r))return Object(s.a)({},n,r)}return n})};e.a=function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:r.a;return function(e,n){var r=e.boxes,a=n.src,o=n.dst,c={},h=r[a.id],u=r[o.id];return Object(i.a)(h)&&(c.src=Object(s.a)({},a,t(h))),Object(i.a)(u)&&(c.dst=Object(s.a)({},o,t(u))),c}}(),e=function(e){return Object(s.a)({},e,{connections:c(e,t)})};return e.deps=function(t){return[t.boxes,t.connections]},e}},"2xrT":function(t,e,n){t.exports=n("md7T")},"31MD":function(t,e,n){var s=n("/6KZ"),r=n("SvME")(!0);s(s.S,"Object",{entries:function(t){return r(t)}})},"6JBb":function(t,e,n){var s=n("/6KZ"),r=n("SvME")(!1);s(s.S,"Object",{values:function(t){return r(t)}})},AXMb:function(t,e,n){n("31MD"),t.exports=n("TaGV").Object.entries},CcWs:function(t,e,n){"use strict";var s=n("Rbzu"),r=n("hCWT"),i=n("K4BZ"),a=n("V+3i"),o=function(t,e){return function(t,e){return Object(a.a)(Object(a.c)(t),Object(a.e)(e))}(t,e)[0]};e.a=function(t,e){var n=t.boxes,a=e.src,c=e.dst,h={},u=n[a.id],l=n[c.id];if(!Object(i.a)(u)||!Object(i.a)(l))return h;var y={src:Object(i.a)(u)?Object(r.a)(u):a,dst:Object(i.a)(l)?Object(r.a)(l):c};return h.src=Object(s.a)({},a,o(y,u)),h.dst=Object(s.a)({},c,o(y,l)),h}},FBSb:function(t,e,n){"use strict";var s=n("1qCV"),r=n.n(s).a;e.a=function(t){return void 0===t||null===t||(t.length?0===t.length:"object"===typeof t&&0===r(t).length)}},K4BZ:function(t,e,n){"use strict";var s=n("Sxkx");e.a=function(t){return t&&Object(s.c)(t.x)&&Object(s.c)(t.y)&&Object(s.c)(t.width)&&Object(s.c)(t.height)}},SQNZ:function(t,e,n){"use strict";n.d(e,"b",function(){return s});var s=function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(function(t){return"none"!==t}(t)?e:0)+.5};e.a=function(t,e){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"none",r=arguments.length>3?arguments[3]:void 0,i=s(n,r);return[t-i,e-i]}},SvME:function(t,e,n){var s=n("lBnu"),r=n("/Lgp"),i=n("T/1i"),a=n("kBaS").f;t.exports=function(t){return function(e){for(var n,o=i(e),c=r(o),h=c.length,u=0,l=[];h>u;)n=c[u++],s&&!a.call(o,n)||l.push(t?[n,o[n]]:o[n]);return l}}},"V+3i":function(t,e,n){"use strict";var s={};n.r(s),n.d(s,"typeName",function(){return y}),n.d(s,"length",function(){return p}),n.d(s,"zip",function(){return d}),n.d(s,"partition",function(){return x}),n.d(s,"reverse",function(){return m}),n.d(s,"sort",function(){return f}),n.d(s,"join",function(){return b}),n.d(s,"keys",function(){return w}),n.d(s,"values",function(){return v}),n.d(s,"pairs",function(){return E}),n.d(s,"fromPairs",function(){return P}),n.d(s,"merge",function(){return k});var r=class{constructor(t=0,e=0){this.x=t,this.y=e}clone(){return new this.constructor(this.x,this.y)}add(t){return new this.constructor(this.x+t.x,this.y+t.y)}subtract(t){return new this.constructor(this.x-t.x,this.y-t.y)}multiply(t){return new this.constructor(this.x*t,this.y*t)}divide(t){return new this.constructor(this.x/t,this.y/t)}equals(t){return this.x===t.x&&this.y===t.y}precisionEquals(t,e){return Math.abs(this.x-t.x)<e&&Math.abs(this.y-t.y)<e}lerp(t,e){const n=1-e;return new this.constructor(this.x*n+t.x*e,this.y*n+t.y*e)}distanceFrom(t){const e=this.x-t.x,n=this.y-t.y;return Math.sqrt(e*e+n*n)}min(t){return new this.constructor(Math.min(this.x,t.x),Math.min(this.y,t.y))}max(t){return new this.constructor(Math.max(this.x,t.x),Math.max(this.y,t.y))}transform(t){return new this.constructor(t.a*this.x+t.c*this.y+t.e,t.b*this.x+t.d*this.y+t.f)}toString(){return`point(${this.x},${this.y})`}};class i{constructor(t=0,e=0){this.x=t,this.y=e}static fromPoints(t,e){return new i(e.x-t.x,e.y-t.y)}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}magnitude(){return this.x*this.x+this.y*this.y}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}determinant(t){return this.x*t.y-this.y*t.x}unit(){return this.divide(this.length())}add(t){return new this.constructor(this.x+t.x,this.y+t.y)}subtract(t){return new this.constructor(this.x-t.x,this.y-t.y)}multiply(t){return new this.constructor(this.x*t,this.y*t)}divide(t){return new this.constructor(this.x/t,this.y/t)}angleBetween(t){let e=this.dot(t)/(this.length()*t.length());e=Math.max(-1,Math.min(e,1));const n=Math.acos(e);return this.cross(t)<0?-n:n}perp(){return new this.constructor(-this.y,this.x)}perpendicular(t){return this.subtract(this.project(t))}project(t){const e=this.dot(t)/t.dot(t);return t.multiply(e)}transform(t){return new this.constructor(t.a*this.x+t.c*this.y,t.b*this.x+t.d*this.y)}equals(t){return this.x===t.x&&this.y===t.y}precisionEquals(t,e){return Math.abs(this.x-t.x)<e&&Math.abs(this.y-t.y)<e}toString(){return`vector(${this.x},${this.y})`}}var a=i;class o{constructor(t=1,e=0,n=0,s=1,r=0,i=0){this.a=t,this.b=e,this.c=n,this.d=s,this.e=r,this.f=i}static translation(t,e){return new o(1,0,0,1,t,e)}static scaling(t){return new o(t,0,0,t,0,0)}static scalingAt(t,e){return new o(t,0,0,t,e.x-e.x*t,e.y-e.y*t)}static nonUniformScaling(t,e){return new o(t,0,0,e,0,0)}static nonUniformScalingAt(t,e,n){return new o(t,0,0,e,n.x-n.x*t,n.y-n.y*e)}static rotation(t){const e=Math.cos(t),n=Math.sin(t);return new o(e,n,-n,e,0,0)}static rotationAt(t,e){const n=Math.cos(t),s=Math.sin(t);return new o(n,s,-s,n,e.x-e.x*n+e.y*s,e.y-e.y*n-e.x*s)}static rotationFromVector(t){const e=t.unit(),n=e.x,s=e.y;return new o(n,s,-s,n,0,0)}static xFlip(){return new o(-1,0,0,1,0,0)}static yFlip(){return new o(1,0,0,-1,0,0)}static xSkew(t){const e=Math.tan(t);return new o(1,0,e,1,0,0)}static ySkew(t){const e=Math.tan(t);return new o(1,e,0,1,0,0)}multiply(t){return this.isIdentity()?t:t.isIdentity()?this:new this.constructor(this.a*t.a+this.c*t.b,this.b*t.a+this.d*t.b,this.a*t.c+this.c*t.d,this.b*t.c+this.d*t.d,this.a*t.e+this.c*t.f+this.e,this.b*t.e+this.d*t.f+this.f)}inverse(){if(this.isIdentity())return this;const t=this.a*this.d-this.b*this.c;if(0===t)throw new Error("Matrix is not invertible");const e=1/t,n=this.f*this.c-this.e*this.d,s=this.e*this.b-this.f*this.a;return new this.constructor(this.d*e,-this.b*e,-this.c*e,this.a*e,n*e,s*e)}translate(t,e){return new this.constructor(this.a,this.b,this.c,this.d,this.a*t+this.c*e+this.e,this.b*t+this.d*e+this.f)}scale(t){return new this.constructor(this.a*t,this.b*t,this.c*t,this.d*t,this.e,this.f)}scaleAt(t,e){const n=e.x-t*e.x,s=e.y-t*e.y;return new this.constructor(this.a*t,this.b*t,this.c*t,this.d*t,this.a*n+this.c*s+this.e,this.b*n+this.d*s+this.f)}scaleNonUniform(t,e){return new this.constructor(this.a*t,this.b*t,this.c*e,this.d*e,this.e,this.f)}scaleNonUniformAt(t,e,n){const s=n.x-t*n.x,r=n.y-e*n.y;return new this.constructor(this.a*t,this.b*t,this.c*e,this.d*e,this.a*s+this.c*r+this.e,this.b*s+this.d*r+this.f)}rotate(t){const e=Math.cos(t),n=Math.sin(t);return new this.constructor(this.a*e+this.c*n,this.b*e+this.d*n,this.a*-n+this.c*e,this.b*-n+this.d*e,this.e,this.f)}rotateAt(t,e){const n=Math.cos(t),s=Math.sin(t),r=e.x,i=e.y,a=this.a*n+this.c*s,o=this.b*n+this.d*s,c=this.c*n-this.a*s,h=this.d*n-this.b*s;return new this.constructor(a,o,c,h,(this.a-a)*r+(this.c-c)*i+this.e,(this.b-o)*r+(this.d-h)*i+this.f)}rotateFromVector(t){const e=t.unit(),n=e.x,s=e.y;return new this.constructor(this.a*n+this.c*s,this.b*n+this.d*s,this.a*-s+this.c*n,this.b*-s+this.d*n,this.e,this.f)}flipX(){return new this.constructor(-this.a,-this.b,this.c,this.d,this.e,this.f)}flipY(){return new this.constructor(this.a,this.b,-this.c,-this.d,this.e,this.f)}skewX(t){const e=Math.tan(t);return new this.constructor(this.a,this.b,this.c+this.a*e,this.d+this.b*e,this.e,this.f)}skewY(t){const e=Math.tan(t);return new this.constructor(this.a+this.c*e,this.b+this.d*e,this.c,this.d,this.e,this.f)}isIdentity(){return 1===this.a&&0===this.b&&0===this.c&&1===this.d&&0===this.e&&0===this.f}isInvertible(){return this.a*this.d-this.b*this.c!==0}getScale(){return{scaleX:Math.sqrt(this.a*this.a+this.c*this.c),scaleY:Math.sqrt(this.b*this.b+this.d*this.d)}}getDecomposition(){const t=.5*(this.a+this.d),e=.5*(this.a-this.d),n=.5*(this.b+this.c),s=.5*(this.b-this.c),r=Math.sqrt(t*t+s*s),i=Math.sqrt(e*e+n*n),a=r+i,o=r-i,c=Math.atan2(n,e),h=Math.atan2(s,t),u=.5*(h-c),l=.5*(h+c);return{translation:this.constructor.translation(this.e,this.f),rotation:this.constructor.rotation(l),scale:this.constructor.nonUniformScaling(a,o),rotation0:this.constructor.rotation(u)}}equals(t){return this.a===t.a&&this.b===t.b&&this.c===t.c&&this.d===t.d&&this.e===t.e&&this.f===t.f}precisionEquals(t,e){return Math.abs(this.a-t.a)<e&&Math.abs(this.b-t.b)<e&&Math.abs(this.c-t.c)<e&&Math.abs(this.d-t.d)<e&&Math.abs(this.e-t.e)<e&&Math.abs(this.f-t.f)<e}toString(){return`matrix(${this.a},${this.b},${this.c},${this.d},${this.e},${this.f})`}}o.IDENTITY=new o,o.IDENTITY.isIdentity=()=>!0;function c(t){return"number"===typeof t?t?t<0?-1:1:t===t?t:NaN:NaN}class h{constructor(...t){this.coefs=[];for(let e=t.length-1;e>=0;e--)this.coefs.push(t[e]);this._variable="t",this._s=0}static interpolate(t,e,n,s,r){if(t.constructor!==Array||e.constructor!==Array)throw new TypeError("xs and ys must be arrays");if(isNaN(n)||isNaN(s)||isNaN(r))throw new TypeError("n, offset, and x must be numbers");let i,a,o=0;const c=new Array(n),h=new Array(n);let u=0,l=Math.abs(r-t[s]);for(i=0;i<n;i++){const n=Math.abs(r-t[s+i]);n<l&&(u=i,l=n),c[i]=h[i]=e[s+i]}a=e[s+u],u--;for(let y=1;y<n;y++){for(i=0;i<n-y;i++){const e=t[s+i]-r,n=t[s+i+y]-r,a=c[i+1]-h[i];let o=e-n;if(0===o)throw new RangeError("Unable to interpolate polynomial. Two numbers in n were identical (to within roundoff)");o=a/o,h[i]=n*o,c[i]=e*o}a+=o=2*(u+1)<n-y?c[u+1]:h[u--]}return{y:a,dy:o}}static newtonSecantBisection(t,e,n,s,r,i){let a,o,h,u,l,y,p,d=0,x=0;a=t;const m=Math.pow(10,-14),f="number"===typeof r&&"number"===typeof i;if(f){if(r>i)throw new RangeError("Min must be greater than max");if(y=e(r),p=e(i),c(y)===c(p))throw new RangeError("Y values of bounds must be of opposite sign")}const b=function(){return Math.abs(h)<=m*Math.abs(a)||x===a-h-a};for(let g=0;g<s;g++){if(0===(o=n(a))){if(0===d)throw new RangeError("df(x) is zero");o=d}if(d=o,l=e(a),u=a-(h=l/o),b())break;if(f){if(c(l)===c(p))i=a,p=l;else{if(c(l)!==c(y)){a=u;break}r=a,y=l}if(u<r||u>i){if(c(y)===c(p))break;const t=50,e=.25,n=p-y,s=i-r;if(h=0===n?a-(r+.5*s):Math.abs(n/Math.min(y,p))>t?a-(r+s*(.5+(Math.abs(y)<Math.abs(p)?-e:e))):a-(r-y/n*s),u=a-h,b())break}}x=a-u,a=u}return a}clone(){const t=new h;return t.coefs=this.coefs.slice(),t}eval(t){if(isNaN(t))throw new TypeError(`Parameter must be a number. Found '${t}'`);let e=0;for(let n=this.coefs.length-1;n>=0;n--)e=e*t+this.coefs[n];return e}add(t){const e=new h,n=this.getDegree(),s=t.getDegree(),r=Math.max(n,s);for(let i=0;i<=r;i++){const r=i<=n?this.coefs[i]:0,a=i<=s?t.coefs[i]:0;e.coefs[i]=r+a}return e}multiply(t){const e=new h;for(let n=0;n<=this.getDegree()+t.getDegree();n++)e.coefs.push(0);for(let n=0;n<=this.getDegree();n++)for(let s=0;s<=t.getDegree();s++)e.coefs[n+s]+=this.coefs[n]*t.coefs[s];return e}divideEqualsScalar(t){for(let e=0;e<this.coefs.length;e++)this.coefs[e]/=t}simplifyEquals(t=1e-12){for(let e=this.getDegree();e>=0&&Math.abs(this.coefs[e])<=t;e--)this.coefs.pop()}removeZerosEquals(t=1e-15){const e=this.coefs,n=10*t*Math.abs(e.reduce((t,e)=>Math.abs(e)>Math.abs(t)?e:t));for(let s=0;s<e.length-1;s++)Math.abs(e[s])<n&&(e[s]=0);return this}monicEquals(){const t=this.coefs;return 1!==t[t.length-1]&&this.divideEqualsScalar(t[t.length-1]),this}toString(){const t=[],e=[];for(let s=this.coefs.length-1;s>=0;s--){let n=Math.round(1e3*this.coefs[s])/1e3;if(0!==n){const r=n<0?" - ":" + ";n=Math.abs(n),s>0&&(1===n?n=this._variable:n+=this._variable),s>1&&(n+="^"+s),e.push(r),t.push(n)}}e[0]=" + "===e[0]?"":"-";let n="";for(let s=0;s<t.length;s++)n+=e[s]+t[s];return n}bisection(t,e,n=1e-6,s=15){let r,i=this.eval(t),a=this.eval(e);if(Math.abs(i)<=n)r=t;else if(Math.abs(a)<=n)r=e;else if(i*a<=0){const o=Math.log(e-t),c=Math.LN10*s,h=Math.ceil((o+c)/Math.LN2);for(let s=0;s<h;s++){r=.5*(t+e);const s=this.eval(r);if(Math.abs(s)<=n)break;s*i<0?(e=r,a=s):(t=r,i=s)}}return r}trapezoid(t,e,n){if(isNaN(t)||isNaN(e)||isNaN(n))throw new TypeError("Parameters must be numbers");const s=e-t;if(1===n){const n=this.eval(t),r=this.eval(e);this._s=.5*s*(n+r)}else{const e=1<<n-2,r=s/e;let i=t+.5*r,a=0;for(let t=0;t<e;t++)a+=this.eval(i),i+=r;this._s=.5*(this._s+s*a/e)}if(isNaN(this._s))throw new TypeError("this._s is NaN");return this._s}simpson(t,e){if(isNaN(t)||isNaN(e))throw new TypeError("Parameters must be numbers");const n=e-t;let s=.5*n*(this.eval(t)+this.eval(e)),r=s,i=4*s/3,a=i,o=s;let c=1;for(let h=2;h<=20;h++){const e=n/c;let h=t+.5*e,u=0;for(let t=1;t<=c;t++)u+=this.eval(h),h+=e;if(i=(4*(s=r=.5*(r+n*u/c))-o)/3,Math.abs(i-a)<1e-7*Math.abs(a))break;a=i,o=s,c<<=1}return i}romberg(t,e){if(isNaN(t)||isNaN(e))throw new TypeError("Parameters must be numbers");const n=new Array(21),s=new Array(21);let r={y:0,dy:0};s[0]=1;for(let i=1;i<=20&&(n[i-1]=this.trapezoid(t,e,i),!(i>=3&&(r=h.interpolate(s,n,3,i-3,0),Math.abs(r.dy)<=1e-6*r.y)));i++)n[i]=n[i-1],s[i]=.25*s[i-1];return r.y}zeroErrorEstimate(t){const e=this;if("undefined"===typeof t){const n=e.bounds();t=Math.max(Math.abs(n.minX),Math.abs(n.maxX))}if(t<.001)return 2*Math.abs(e.eval(1e-15));const n=e.coefs.length-1,s=e.coefs[n];return 10*1e-15*e.coefs.reduce((e,n,r)=>{const i=n/s*Math.pow(t,r);return i>e?i:e},0)}boundsUpperRealFujiwara(){let t=this.coefs;const e=t.length-1,n=t[e];1!==n&&(t=this.coefs.map(t=>t/n));const s=t.map((t,n)=>n<e?Math.pow(Math.abs(0===n?t/2:t),1/(e-n)):t);let r;const i=function(t,e,n){return r(n)&&(t.max<e?(t.nearmax=t.max,t.max=e):t.nearmax<e&&(t.nearmax=e)),t};r=function(n){return n<e&&t[n]<0};const a=s.reduce(i,{max:0,nearmax:0});return r=function(n){return n<e&&(e%2===n%2?t[n]<0:t[n]>0)},{negX:-2*s.reduce(i,{max:0,nearmax:0}).max,posX:2*a.max}}boundsLowerRealFujiwara(){const t=new h;t.coefs=this.coefs.slice().reverse();const e=t.boundsUpperRealFujiwara();return e.negX=1/e.negX,e.posX=1/e.posX,e}bounds(){const t=this.boundsUpperRealFujiwara(),e={minX:t.negX,maxX:t.posX};return 0===t.negX&&0===t.posX?e:(0===t.negX?e.minX=this.boundsLowerRealFujiwara().posX:0===t.posX&&(e.maxX=this.boundsLowerRealFujiwara().negX),e.minX>e.maxX&&(e.minX=e.maxX=0),e)}boundUpperAbsRouche(){const t=this.coefs,e=t.length-1;return 1+t.reduce((t,n,s)=>s!==e&&t<(n=Math.abs(n))?n:t,0)/Math.abs(t[e])}boundLowerAbsRouche(){const t=this.coefs,e=t.reduce((t,e,n)=>0!==n&&t<(e=Math.abs(e))?e:t,0);return Math.abs(t[0])/(Math.abs(t[0])+e)}boundsRealLaguerre(){const t=this.coefs,e=t.length-1,n=-t[e-1]/(e*t[e]),s=t[e-1]*t[e-1]-2*e/(e-1)*t[e]*t[e-2];let r=(e-1)/(e*t[e])*Math.sqrt(s);return r<0&&(r=-r),{minX:n-r,maxX:n+r}}countRootsDescartes(){const t=this.coefs,e=t.length-1,n=t.reduce((t,e,n)=>(0!==t.prev_a&&0!==e&&(t.prev_a<0===e>0&&t.pos++,n%2===0!==t.prev_a<0===(n%2===1!==e>0)&&t.neg++),t.prev_a=e,t),{pos:0,neg:0,prev_a:0});return{maxRealPos:n.pos,maxRealNeg:n.neg,minComplex:e-(n.pos+n.neg)}}getDegree(){return this.coefs.length-1}getDerivative(){const t=new h;for(let e=1;e<this.coefs.length;e++)t.coefs.push(e*this.coefs[e]);return t}getRoots(){let t;switch(this.simplifyEquals(),this.getDegree()){case 0:t=[];break;case 1:t=this.getLinearRoot();break;case 2:t=this.getQuadraticRoots();break;case 3:t=this.getCubicRoots();break;case 4:t=this.getQuarticRoots();break;default:t=[]}return t}getRootsInInterval(t,e){const n=[];function s(t){"number"===typeof t&&n.push(t)}if(0===this.getDegree())throw new RangeError("Unexpected empty polynomial");if(1===this.getDegree())s(this.bisection(t,e));else{const n=this.getDerivative().getRootsInInterval(t,e);if(n.length>0){s(this.bisection(t,n[0]));for(let t=0;t<=n.length-2;t++)s(this.bisection(n[t],n[t+1]));s(this.bisection(n[n.length-1],e))}else s(this.bisection(t,e))}return n}getLinearRoot(){const t=[],e=this.coefs[1];return 0!==e&&t.push(-this.coefs[0]/e),t}getQuadraticRoots(){const t=[];if(2===this.getDegree()){const e=this.coefs[2],n=this.coefs[1]/e,s=n*n-4*(this.coefs[0]/e);if(s>0){const e=Math.sqrt(s);t.push(.5*(-n+e)),t.push(.5*(-n-e))}else 0===s&&t.push(.5*-n)}return t}getCubicRoots(){const t=[];if(3===this.getDegree()){const e=this.coefs[3],n=this.coefs[2]/e,s=this.coefs[1]/e,r=(3*s-n*n)/3,i=(2*n*n*n-9*s*n+27*(this.coefs[0]/e))/27,a=n/3;let o=i*i/4+r*r*r/27;const c=i/2,h=this.zeroErrorEstimate();if(Math.abs(o)<=h&&(o=0),o>0){const e=Math.sqrt(o);let n,s=-c+e;n=s>=0?Math.pow(s,1/3):-Math.pow(-s,1/3),(s=-c-e)>=0?n+=Math.pow(s,1/3):n-=Math.pow(-s,1/3),t.push(n-a)}else if(o<0){const e=Math.sqrt(-r/3),n=Math.atan2(Math.sqrt(-o),-c)/3,s=Math.cos(n),i=Math.sin(n),h=Math.sqrt(3);t.push(2*e*s-a),t.push(-e*(s+h*i)-a),t.push(-e*(s-h*i)-a)}else{let e;e=c>=0?-Math.pow(c,1/3):Math.pow(-c,1/3),t.push(2*e-a),t.push(-e-a)}}return t}getQuarticRoots(){let t=[];const e=this.getDegree();if(4===e){const n=new h;n.coefs=this.coefs.slice(),n.divideEqualsScalar(n.coefs[e]);const s=1e-15;Math.abs(n.coefs[0])<10*s*Math.abs(n.coefs[3])&&(n.coefs[0]=0);const r=n.getDerivative(),i=r.getRoots().sort((t,e)=>t-e),a=[],o=i.length-1,u=this.bounds(),l=Math.max(Math.abs(u.minX),Math.abs(u.maxX)),y=this.zeroErrorEstimate(l);for(let t=0;t<=o;t++)a.push(n.eval(i[t]));for(let t=0;t<=o;t++)Math.abs(a[t])<y&&(a[t]=0);let p=0;const d=Math.max(.1*(u.maxX-u.minX)/e,s),x=[],m=[];if(o>-1){for(0!==a[0]?c(a[0])!==c(n.eval(i[0]-d)-a[0])&&(x.push(i[0]-d),m.push([u.minX,i[0]])):(t.push(i[0],i[0]),p++);p<o;p++)0===a[p+1]?(t.push(i[p+1],i[p+1]),p++):c(a[p])!==c(a[p+1])&&(x.push((i[p]+i[p+1])/2),m.push([i[p],i[p+1]]));0!==a[o]&&c(a[o])!==c(n.eval(i[o]+d)-a[o])&&(x.push(i[o]+d),m.push([i[o],u.maxX]))}const f=function(t){return n.eval(t)},b=function(t){return r.eval(t)};if(x.length>0)for(p=0;p<x.length;p++)x[p]=h.newtonSecantBisection(x[p],f,b,32,m[p][0],m[p][1]);t=t.concat(x)}return t}}var u=h;var l=function(){var t=function(t,e,n,s){for(n=n||{},s=t.length;s--;n[t[s]]=e);return n},e=[1,6],n=[1,17],s=[1,7],r=[1,10],i=[1,13],a=[1,28],o=[1,14],c=[1,34],h=[1,15],u=[1,33],l=[1,21],y=[1,24],p=[1,25],d=[1,29],x=[1,30],m=[1,32],f=[1,31],b=[1,5],g=[1,5,14,16,24,28,41],w=[1,57],v=[1,59],E=[1,58],P=[1,46],k=[1,52],M=[1,41],O=[1,42],j=[1,43],A=[1,44],T=[1,45],R=[1,47],N=[1,49],I=[1,50],_=[1,55],X=[1,56],$=[1,5,14,16,24,28,41,54],C=[1,5,14,16,24,28,31,32,33,34,41,54],Y=[1,5,14,16,24,28,31,32,33,34,38,40,41,54],L=[1,5,14,16,24,28,31,32,33,34,38,40,41,54,58],S=[1,5,14,16,24,28,41,58],B=[1,93],D=[1,98],z=[1,112],q=[1,115],F=[14,41],U=[14,28],Q=[1,127],W=[14,24,41],Z=[14,24,41,58],G=[14,28,58],V=[14,24],H=[1,5,14,28,41],J=[1,151],K={trace:function(){},yy:{},symbols_:{error:2,program:3,statements:4,";":5,statement:6,assignment:7,sequence:8,LET:9,IDENTIFIER:10,"=":11,DEF:12,sequences:13,",":14,steps:15,"|>":16,step:17,"=~":18,namedPattern:19,expression:20,mathExpression:21,MAP:22,"(":23,")":24,PATTERNS:25,"{":26,patterns:27,"}":28,SEQUENCES:29,callExpression:30,"+":31,"-":32,"*":33,"/":34,argumentList:35,memberExpression:36,primaryExpression:37,".":38,integer:39,"[":40,"]":41,boolean:42,NULL_TYPE:43,float:44,string:45,UNDEFINED_TYPE:46,$:47,arrayExpression:48,objectExpression:49,expressionElements:50,expressionElement:51,expressionProperties:52,expressionProperty:53,":":54,argument:55,"...":56,pattern:57,AS:58,ANY_TYPE:59,ARRAY_TYPE:60,BOOLEAN_TYPE:61,TRUE:62,FALSE:63,NUMBER_TYPE:64,OBJECT_TYPE:65,STRING_TYPE:66,arrayPattern:67,objectPattern:68,PATTERN:69,ENUMERATION:70,patternElements:71,namedPatternElement:72,patternElement:73,range:74,"..":75,patternProperties:76,namedPatternProperty:77,namedProperty:78,STRING:79,NUMBER:80,stringOrIdentifier:81,identifiers:82,$accept:0,$end:1},terminals_:{2:"error",5:";",9:"LET",10:"IDENTIFIER",11:"=",12:"DEF",14:",",16:"|>",18:"=~",22:"MAP",23:"(",24:")",25:"PATTERNS",26:"{",28:"}",29:"SEQUENCES",31:"+",32:"-",33:"*",34:"/",38:".",40:"[",41:"]",43:"NULL_TYPE",46:"UNDEFINED_TYPE",47:"$",54:":",56:"...",58:"AS",59:"ANY_TYPE",60:"ARRAY_TYPE",61:"BOOLEAN_TYPE",62:"TRUE",63:"FALSE",64:"NUMBER_TYPE",65:"OBJECT_TYPE",66:"STRING_TYPE",69:"PATTERN",70:"ENUMERATION",75:"..",79:"STRING",80:"NUMBER"},productions_:[0,[3,1],[3,2],[4,3],[4,1],[6,1],[6,1],[7,4],[7,4],[13,3],[13,1],[8,1],[15,3],[15,1],[17,2],[17,1],[20,1],[20,6],[20,4],[20,4],[21,1],[21,3],[21,3],[21,3],[21,3],[30,3],[30,4],[30,1],[36,1],[36,3],[36,3],[36,4],[37,1],[37,1],[37,1],[37,1],[37,1],[37,1],[37,1],[37,1],[37,1],[37,3],[48,2],[48,3],[50,3],[50,1],[51,1],[51,1],[49,2],[49,3],[52,3],[52,1],[53,3],[53,1],[53,1],[35,3],[35,1],[55,1],[55,2],[27,3],[27,1],[19,1],[19,3],[57,1],[57,1],[57,1],[57,1],[57,1],[57,1],[57,1],[57,1],[57,1],[57,1],[57,1],[57,1],[57,1],[57,1],[57,2],[57,2],[57,1],[67,2],[67,3],[71,3],[71,1],[72,1],[72,3],[73,1],[73,3],[73,3],[73,5],[74,3],[74,2],[74,2],[74,1],[68,2],[68,3],[76,3],[76,1],[77,1],[77,3],[78,3],[78,1],[42,1],[42,1],[45,1],[39,1],[44,1],[81,1],[81,1],[82,3],[82,1]],performAction:function(t,e,n,s,r,i,a){var o=i.length-1;switch(r){case 1:return i[o];case 2:return i[o-1];case 3:case 9:case 12:case 44:case 50:case 55:case 59:case 82:case 96:case 109:i[o-2].push(i[o]),this.$=i[o-2];break;case 4:case 10:case 13:case 45:case 51:case 56:case 60:case 83:case 97:case 110:this.$=[i[o]];break;case 5:case 6:case 14:case 15:case 16:case 20:case 27:case 28:case 39:case 40:case 46:case 47:case 54:case 57:case 98:case 107:this.$=i[o];break;case 7:this.$={type:"assignment",name:i[o-2],value:i[o]};break;case 8:this.$={type:"def",name:i[o-2],value:i[o]};break;case 11:this.$={type:"sequence",steps:i[o]};break;case 17:this.$={type:"map",value:[i[o-3],i[o-1]]};break;case 18:this.$={type:"patterns",patterns:i[o-1]};break;case 19:this.$={type:"sequences",sequences:i[o-1]};break;case 21:this.$={type:"add",left:i[o-2],right:i[o]};break;case 22:this.$={type:"subtract",left:i[o-2],right:i[o]};break;case 23:this.$={type:"multiply",left:i[o-2],right:i[o]};break;case 24:this.$={type:"divide",left:i[o-2],right:i[o]};break;case 25:this.$={type:"invoke",name:i[o-2],args:[]};break;case 26:this.$={type:"invoke",name:i[o-3],args:i[o-1]};break;case 29:this.$={type:"get-property",left:i[o-2],right:i[o]};break;case 30:this.$={type:"get-index",left:i[o-2],right:i[o]};break;case 31:this.$={type:"get-index",left:i[o-3],right:i[o-1]};break;case 32:this.$={type:"boolean",value:i[o]};break;case 33:this.$={type:"boolean",value:null};break;case 34:this.$={type:"number",value:i[o]};break;case 35:this.$={type:"string",value:i[o]};break;case 36:this.$={type:"undefined",value:void 0};break;case 37:this.$={type:"get-value",name:i[o]};break;case 38:this.$={type:"get-structure"};break;case 41:this.$=i[o-1];break;case 42:this.$={type:"array",value:[]};break;case 43:this.$={type:"array",value:i[o-1]};break;case 48:this.$={type:"object",value:[]};break;case 49:this.$={type:"object",value:i[o-1]};break;case 52:this.$={type:"property",name:i[o-2],value:i[o]};break;case 53:this.$={type:"property",name:i[o],value:null};break;case 58:this.$={type:"spread",expression:i[o]};break;case 61:case 84:i[o].assignTo=null,this.$=i[o];break;case 62:case 85:case 99:i[o-2].assignTo=i[o],this.$=i[o-2];break;case 63:this.$={type:"pattern",patternType:"any",value:null};break;case 64:this.$={type:"pattern",patternType:"array",value:null};break;case 65:this.$={type:"pattern",patternType:"boolean",value:null};break;case 66:this.$={type:"pattern",patternType:"boolean",value:!0};break;case 67:this.$={type:"pattern",patternType:"boolean",value:!1};break;case 68:this.$={type:"pattern",patternType:"null",value:null};break;case 69:this.$={type:"pattern",patternType:"number",value:null};break;case 70:this.$={type:"pattern",patternType:"number",value:i[o]};break;case 71:this.$={type:"pattern",patternType:"object",value:null};break;case 72:this.$={type:"pattern",patternType:"string",value:null};break;case 73:this.$={type:"pattern",patternType:"string",value:i[o]};break;case 74:this.$={type:"pattern",patternType:"undefined",value:null};break;case 75:case 76:this.$=i[o];break;case 77:this.$={type:"pattern-reference",name:i[o]};break;case 78:this.$={type:"enumeration-reference",name:i[o]};break;case 79:this.$={type:"pattern",patternType:"reference",value:i[o]};break;case 80:this.$={type:"pattern",patternType:"array-pattern",value:[]};break;case 81:this.$={type:"pattern",patternType:"array-pattern",value:i[o-1]};break;case 86:this.$={type:"element",pattern:i[o],range:{type:"range",start:1,stop:1}};break;case 87:this.$={type:"element",pattern:i[o-2],range:i[o]};break;case 88:this.$={type:"element-group",elements:i[o-1],range:{type:"range",start:1,stop:1}};break;case 89:this.$={type:"element-group",elements:i[o-3],range:i[o]};break;case 90:this.$={type:"range",start:i[o-2],stop:i[o]};break;case 91:this.$={type:"range",start:0,stop:i[o]};break;case 92:this.$={type:"range",start:i[o-1],stop:1/0};break;case 93:this.$={type:"range",start:i[o],stop:i[o]};break;case 94:this.$={type:"pattern",patternType:"object",value:null};break;case 95:this.$={type:"pattern",patternType:"object-pattern",value:i[o-1]};break;case 100:this.$={type:"property",name:i[o-2],pattern:i[o]};break;case 101:this.$={type:"property",name:i[o],pattern:{type:"pattern",patternType:"any",value:null}};break;case 102:this.$=!0;break;case 103:this.$=!1;break;case 104:case 108:this.$=i[o].substring(1,i[o].length-1);break;case 105:this.$=parseInt(i[o]);break;case 106:this.$=parseFloat(i[o])}},table:[{3:1,4:2,6:3,7:4,8:5,9:e,10:n,12:s,15:8,17:9,18:r,20:11,21:12,22:i,23:a,25:o,26:c,29:h,30:16,36:18,37:19,40:u,42:20,43:l,44:22,45:23,46:y,47:p,48:26,49:27,62:d,63:x,79:m,80:f},{1:[3]},{1:[2,1],5:[1,35]},t(b,[2,4]),t(b,[2,5]),t(b,[2,6]),{10:[1,36]},{10:[1,37]},t([1,5,14,24,28,41],[2,11],{16:[1,38]}),t(g,[2,13]),{10:w,19:39,26:v,40:E,43:P,44:48,45:51,46:k,57:40,59:M,60:O,61:j,62:A,63:T,64:R,65:N,66:I,67:53,68:54,69:_,70:X,79:m,80:f},t(g,[2,15]),t($,[2,16],{31:[1,60],32:[1,61],33:[1,62],34:[1,63]}),{23:[1,64]},{26:[1,65]},{26:[1,66]},t(C,[2,20]),t(Y,[2,37],{23:[1,67]}),t(C,[2,27],{38:[1,68],40:[1,69]}),t(Y,[2,28]),t(Y,[2,32]),t(Y,[2,33]),t(Y,[2,34]),t(Y,[2,35]),t(Y,[2,36]),t(Y,[2,38]),t(Y,[2,39]),t(Y,[2,40]),{10:n,20:70,21:12,22:i,23:a,25:o,26:c,29:h,30:16,36:18,37:19,40:u,42:20,43:l,44:22,45:23,46:y,47:p,48:26,49:27,62:d,63:x,79:m,80:f},t(Y,[2,102]),t(Y,[2,103]),t(L,[2,106]),t(L,[2,104]),{7:75,9:e,10:n,12:s,20:74,21:12,22:i,23:a,25:o,26:c,29:h,30:16,36:18,37:19,40:u,41:[1,71],42:20,43:l,44:22,45:23,46:y,47:p,48:26,49:27,50:72,51:73,62:d,63:x,79:m,80:f},{7:80,9:e,10:n,12:s,20:79,21:12,22:i,23:a,25:o,26:c,28:[1,76],29:h,30:16,36:18,37:19,40:u,42:20,43:l,44:22,45:23,46:y,47:p,48:26,49:27,52:77,53:78,62:d,63:x,79:m,80:f},{1:[2,2],6:81,7:4,8:5,9:e,10:n,12:s,15:8,17:9,18:r,20:11,21:12,22:i,23:a,25:o,26:c,29:h,30:16,36:18,37:19,40:u,42:20,43:l,44:22,45:23,46:y,47:p,48:26,49:27,62:d,63:x,79:m,80:f},{11:[1,82]},{11:[1,83]},{10:n,17:84,18:r,20:11,21:12,22:i,23:a,25:o,26:c,29:h,30:16,36:18,37:19,40:u,42:20,43:l,44:22,45:23,46:y,47:p,48:26,49:27,62:d,63:x,79:m,80:f},t(g,[2,14]),t(g,[2,61],{58:[1,85]}),t(S,[2,63]),t(S,[2,64]),t(S,[2,65]),t(S,[2,66]),t(S,[2,67]),t(S,[2,68]),t(S,[2,69]),t(S,[2,70]),t(S,[2,71]),t(S,[2,72]),t(S,[2,73]),t(S,[2,74]),t(S,[2,75]),t(S,[2,76]),{10:[1,86]},{10:[1,87]},t(S,[2,79]),{10:w,23:B,26:v,40:E,41:[1,88],43:P,44:48,45:51,46:k,57:92,59:M,60:O,61:j,62:A,63:T,64:R,65:N,66:I,67:53,68:54,69:_,70:X,71:89,72:90,73:91,79:m,80:f},{10:D,28:[1,94],76:95,77:96,78:97},{10:n,23:a,26:c,30:99,36:18,37:19,40:u,42:20,43:l,44:22,45:23,46:y,47:p,48:26,49:27,62:d,63:x,79:m,80:f},{10:n,23:a,26:c,30:100,36:18,37:19,40:u,42:20,43:l,44:22,45:23,46:y,47:p,48:26,49:27,62:d,63:x,79:m,80:f},{10:n,23:a,26:c,30:101,36:18,37:19,40:u,42:20,43:l,44:22,45:23,46:y,47:p,48:26,49:27,62:d,63:x,79:m,80:f},{10:n,23:a,26:c,30:102,36:18,37:19,40:u,42:20,43:l,44:22,45:23,46:y,47:p,48:26,49:27,62:d,63:x,79:m,80:f},{10:n,20:103,21:12,22:i,23:a,25:o,26:c,29:h,30:16,36:18,37:19,40:u,42:20,43:l,44:22,45:23,46:y,47:p,48:26,49:27,62:d,63:x,79:m,80:f},{10:w,19:105,26:v,27:104,40:E,43:P,44:48,45:51,46:k,57:40,59:M,60:O,61:j,62:A,63:T,64:R,65:N,66:I,67:53,68:54,69:_,70:X,79:m,80:f},{8:107,10:n,13:106,15:8,17:9,18:r,20:11,21:12,22:i,23:a,25:o,26:c,29:h,30:16,36:18,37:19,40:u,42:20,43:l,44:22,45:23,46:y,47:p,48:26,49:27,62:d,63:x,79:m,80:f},{10:n,20:111,21:12,22:i,23:a,24:[1,108],25:o,26:c,29:h,30:16,35:109,36:18,37:19,40:u,42:20,43:l,44:22,45:23,46:y,47:p,48:26,49:27,55:110,56:z,62:d,63:x,79:m,80:f},{10:[1,113],39:114,80:q},{39:116,80:q},{24:[1,117]},t(Y,[2,42]),{14:[1,119],41:[1,118]},t(F,[2,45]),t(F,[2,46]),t(F,[2,47]),t(Y,[2,48]),{14:[1,121],28:[1,120]},t(U,[2,51]),t(U,[2,53],{54:[1,122]}),t(U,[2,54]),t(b,[2,3]),{8:123,10:n,15:8,17:9,18:r,20:11,21:12,22:i,23:a,25:o,26:c,29:h,30:16,36:18,37:19,40:u,42:20,43:l,44:22,45:23,46:y,47:p,48:26,49:27,62:d,63:x,79:m,80:f},{8:124,10:n,15:8,17:9,18:r,20:11,21:12,22:i,23:a,25:o,26:c,29:h,30:16,36:18,37:19,40:u,42:20,43:l,44:22,45:23,46:y,47:p,48:26,49:27,62:d,63:x,79:m,80:f},t(g,[2,12]),{10:[1,125]},t(S,[2,77]),t(S,[2,78]),t(S,[2,80]),{14:Q,41:[1,126]},t(W,[2,83]),t(W,[2,84],{58:[1,128]}),t(Z,[2,86],{5:[1,129]}),{10:w,23:B,26:v,40:E,43:P,44:48,45:51,46:k,57:92,59:M,60:O,61:j,62:A,63:T,64:R,65:N,66:I,67:53,68:54,69:_,70:X,71:130,72:90,73:91,79:m,80:f},t(S,[2,94]),{14:[1,132],28:[1,131]},t(U,[2,97]),t(U,[2,98],{58:[1,133]}),t(G,[2,101],{54:[1,134]}),t(C,[2,21]),t(C,[2,22]),t(C,[2,23]),t(C,[2,24]),{14:[1,135]},{14:[1,137],28:[1,136]},t(U,[2,60]),{14:[1,139],28:[1,138]},t(U,[2,10]),t(C,[2,25]),{14:[1,141],24:[1,140]},t(V,[2,56]),t(V,[2,57]),{10:n,20:142,21:12,22:i,23:a,25:o,26:c,29:h,30:16,36:18,37:19,40:u,42:20,43:l,44:22,45:23,46:y,47:p,48:26,49:27,62:d,63:x,79:m,80:f},t(Y,[2,29]),t(Y,[2,30]),t([1,5,14,16,24,28,31,32,33,34,38,40,41,54,58,75],[2,105]),{41:[1,143]},t(Y,[2,41]),t(Y,[2,43]),{7:75,9:e,10:n,12:s,20:74,21:12,22:i,23:a,25:o,26:c,29:h,30:16,36:18,37:19,40:u,42:20,43:l,44:22,45:23,46:y,47:p,48:26,49:27,51:144,62:d,63:x,79:m,80:f},t(Y,[2,49]),{7:80,9:e,10:n,12:s,20:79,21:12,22:i,23:a,25:o,26:c,29:h,30:16,36:18,37:19,40:u,42:20,43:l,44:22,45:23,46:y,47:p,48:26,49:27,53:145,62:d,63:x,79:m,80:f},{8:146,10:n,15:8,17:9,18:r,20:11,21:12,22:i,23:a,25:o,26:c,29:h,30:16,36:18,37:19,40:u,42:20,43:l,44:22,45:23,46:y,47:p,48:26,49:27,62:d,63:x,79:m,80:f},t(H,[2,7]),t(H,[2,8]),t(g,[2,62]),t(S,[2,81]),{10:w,23:B,26:v,40:E,43:P,44:48,45:51,46:k,57:92,59:M,60:O,61:j,62:A,63:T,64:R,65:N,66:I,67:53,68:54,69:_,70:X,72:147,73:91,79:m,80:f},{10:[1,148]},{39:150,74:149,75:J,80:q},{14:Q,24:[1,152]},t(S,[2,95]),{10:D,77:153,78:97},{10:[1,154]},{10:w,26:v,40:E,43:P,44:48,45:51,46:k,57:155,59:M,60:O,61:j,62:A,63:T,64:R,65:N,66:I,67:53,68:54,69:_,70:X,79:m,80:f},{8:156,10:n,15:8,17:9,18:r,20:11,21:12,22:i,23:a,25:o,26:c,29:h,30:16,36:18,37:19,40:u,42:20,43:l,44:22,45:23,46:y,47:p,48:26,49:27,62:d,63:x,79:m,80:f},t($,[2,18]),{10:w,19:157,26:v,40:E,43:P,44:48,45:51,46:k,57:40,59:M,60:O,61:j,62:A,63:T,64:R,65:N,66:I,67:53,68:54,69:_,70:X,79:m,80:f},t($,[2,19]),{8:158,10:n,15:8,17:9,18:r,20:11,21:12,22:i,23:a,25:o,26:c,29:h,30:16,36:18,37:19,40:u,42:20,43:l,44:22,45:23,46:y,47:p,48:26,49:27,62:d,63:x,79:m,80:f},t(C,[2,26]),{10:n,20:111,21:12,22:i,23:a,25:o,26:c,29:h,30:16,36:18,37:19,40:u,42:20,43:l,44:22,45:23,46:y,47:p,48:26,49:27,55:159,56:z,62:d,63:x,79:m,80:f},t(V,[2,58]),t(Y,[2,31]),t(F,[2,44]),t(U,[2,50]),t(U,[2,52]),t(W,[2,82]),t(W,[2,85]),t(Z,[2,87]),t(Z,[2,93],{75:[1,160]}),{39:161,80:q},t(Z,[2,88],{5:[1,162]}),t(U,[2,96]),t(U,[2,99]),t(G,[2,100]),{24:[1,163]},t(U,[2,59]),t(U,[2,9]),t(V,[2,55]),t(Z,[2,92],{39:164,80:q}),t(Z,[2,91]),{39:150,74:165,75:J,80:q},t($,[2,17]),t(Z,[2,90]),t(Z,[2,89])],defaultActions:{},parseError:function(t,e){if(!e.recoverable){var n=new Error(t);throw n.hash=e,n}this.trace(t)},parse:function(t){var e=this,n=[0],s=[null],r=[],i=this.table,a="",o=0,c=0,h=0,u=r.slice.call(arguments,1),l=Object.create(this.lexer),y={yy:{}};for(var p in this.yy)Object.prototype.hasOwnProperty.call(this.yy,p)&&(y.yy[p]=this.yy[p]);l.setInput(t,y.yy),y.yy.lexer=l,y.yy.parser=this,"undefined"==typeof l.yylloc&&(l.yylloc={});var d=l.yylloc;r.push(d);var x=l.options&&l.options.ranges;"function"===typeof y.yy.parseError?this.parseError=y.yy.parseError:this.parseError=Object.getPrototypeOf(this).parseError;for(var m,f,b,g,w,v,E,P,k,M=function(){var t;return"number"!==typeof(t=l.lex()||1)&&(t=e.symbols_[t]||t),t},O={};;){if(b=n[n.length-1],this.defaultActions[b]?g=this.defaultActions[b]:(null!==m&&"undefined"!=typeof m||(m=M()),g=i[b]&&i[b][m]),"undefined"===typeof g||!g.length||!g[0]){var j="";for(v in k=[],i[b])this.terminals_[v]&&v>2&&k.push("'"+this.terminals_[v]+"'");j=l.showPosition?"Parse error on line "+(o+1)+":\n"+l.showPosition()+"\nExpecting "+k.join(", ")+", got '"+(this.terminals_[m]||m)+"'":"Parse error on line "+(o+1)+": Unexpected "+(1==m?"end of input":"'"+(this.terminals_[m]||m)+"'"),this.parseError(j,{text:l.match,token:this.terminals_[m]||m,line:l.yylineno,loc:d,expected:k})}if(g[0]instanceof Array&&g.length>1)throw new Error("Parse Error: multiple actions possible at state: "+b+", token: "+m);switch(g[0]){case 1:n.push(m),s.push(l.yytext),r.push(l.yylloc),n.push(g[1]),m=null,f?(m=f,f=null):(c=l.yyleng,a=l.yytext,o=l.yylineno,d=l.yylloc,h>0&&h--);break;case 2:if(E=this.productions_[g[1]][1],O.$=s[s.length-E],O._$={first_line:r[r.length-(E||1)].first_line,last_line:r[r.length-1].last_line,first_column:r[r.length-(E||1)].first_column,last_column:r[r.length-1].last_column},x&&(O._$.range=[r[r.length-(E||1)].range[0],r[r.length-1].range[1]]),"undefined"!==typeof(w=this.performAction.apply(O,[a,c,o,y.yy,g[1],s,r].concat(u))))return w;E&&(n=n.slice(0,-1*E*2),s=s.slice(0,-1*E),r=r.slice(0,-1*E)),n.push(this.productions_[g[1]][0]),s.push(O.$),r.push(O._$),P=i[n[n.length-2]][n[n.length-1]],n.push(P);break;case 3:return!0}}return!0}},tt={EOF:1,parseError:function(t,e){if(!this.yy.parser)throw new Error(t);this.yy.parser.parseError(t,e)},setInput:function(t,e){return this.yy=e||this.yy||{},this._input=t,this._more=this._backtrack=this.done=!1,this.yylineno=this.yyleng=0,this.yytext=this.matched=this.match="",this.conditionStack=["INITIAL"],this.yylloc={first_line:1,first_column:0,last_line:1,last_column:0},this.options.ranges&&(this.yylloc.range=[0,0]),this.offset=0,this},input:function(){var t=this._input[0];return this.yytext+=t,this.yyleng++,this.offset++,this.match+=t,this.matched+=t,t.match(/(?:\r\n?|\n).*/g)?(this.yylineno++,this.yylloc.last_line++):this.yylloc.last_column++,this.options.ranges&&this.yylloc.range[1]++,this._input=this._input.slice(1),t},unput:function(t){var e=t.length,n=t.split(/(?:\r\n?|\n)/g);this._input=t+this._input,this.yytext=this.yytext.substr(0,this.yytext.length-e),this.offset-=e;var s=this.match.split(/(?:\r\n?|\n)/g);this.match=this.match.substr(0,this.match.length-1),this.matched=this.matched.substr(0,this.matched.length-1),n.length-1&&(this.yylineno-=n.length-1);var r=this.yylloc.range;return this.yylloc={first_line:this.yylloc.first_line,last_line:this.yylineno+1,first_column:this.yylloc.first_column,last_column:n?(n.length===s.length?this.yylloc.first_column:0)+s[s.length-n.length].length-n[0].length:this.yylloc.first_column-e},this.options.ranges&&(this.yylloc.range=[r[0],r[0]+this.yyleng-e]),this.yyleng=this.yytext.length,this},more:function(){return this._more=!0,this},reject:function(){return this.options.backtrack_lexer?(this._backtrack=!0,this):this.parseError("Lexical error on line "+(this.yylineno+1)+". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n"+this.showPosition(),{text:"",token:null,line:this.yylineno})},less:function(t){this.unput(this.match.slice(t))},pastInput:function(){var t=this.matched.substr(0,this.matched.length-this.match.length);return(t.length>20?"...":"")+t.substr(-20).replace(/\n/g,"")},upcomingInput:function(){var t=this.match;return t.length<20&&(t+=this._input.substr(0,20-t.length)),(t.substr(0,20)+(t.length>20?"...":"")).replace(/\n/g,"")},showPosition:function(){var t=this.pastInput(),e=new Array(t.length+1).join("-");return t+this.upcomingInput()+"\n"+e+"^"},test_match:function(t,e){var n,s,r;if(this.options.backtrack_lexer&&(r={yylineno:this.yylineno,yylloc:{first_line:this.yylloc.first_line,last_line:this.last_line,first_column:this.yylloc.first_column,last_column:this.yylloc.last_column},yytext:this.yytext,match:this.match,matches:this.matches,matched:this.matched,yyleng:this.yyleng,offset:this.offset,_more:this._more,_input:this._input,yy:this.yy,conditionStack:this.conditionStack.slice(0),done:this.done},this.options.ranges&&(r.yylloc.range=this.yylloc.range.slice(0))),(s=t[0].match(/(?:\r\n?|\n).*/g))&&(this.yylineno+=s.length),this.yylloc={first_line:this.yylloc.last_line,last_line:this.yylineno+1,first_column:this.yylloc.last_column,last_column:s?s[s.length-1].length-s[s.length-1].match(/\r?\n?/)[0].length:this.yylloc.last_column+t[0].length},this.yytext+=t[0],this.match+=t[0],this.matches=t,this.yyleng=this.yytext.length,this.options.ranges&&(this.yylloc.range=[this.offset,this.offset+=this.yyleng]),this._more=!1,this._backtrack=!1,this._input=this._input.slice(t[0].length),this.matched+=t[0],n=this.performAction.call(this,this.yy,this,e,this.conditionStack[this.conditionStack.length-1]),this.done&&this._input&&(this.done=!1),n)return n;if(this._backtrack){for(var i in r)this[i]=r[i];return!1}return!1},next:function(){if(this.done)return this.EOF;var t,e,n,s;this._input||(this.done=!0),this._more||(this.yytext="",this.match="");for(var r=this._currentRules(),i=0;i<r.length;i++)if((n=this._input.match(this.rules[r[i]]))&&(!e||n[0].length>e[0].length)){if(e=n,s=i,this.options.backtrack_lexer){if(!1!==(t=this.test_match(n,r[i])))return t;if(this._backtrack){e=!1;continue}return!1}if(!this.options.flex)break}return e?!1!==(t=this.test_match(e,r[s]))&&t:""===this._input?this.EOF:this.parseError("Lexical error on line "+(this.yylineno+1)+". Unrecognized text.\n"+this.showPosition(),{text:"",token:null,line:this.yylineno})},lex:function(){var t=this.next();return t||this.lex()},begin:function(t){this.conditionStack.push(t)},popState:function(){return this.conditionStack.length-1>0?this.conditionStack.pop():this.conditionStack[0]},_currentRules:function(){return this.conditionStack.length&&this.conditionStack[this.conditionStack.length-1]?this.conditions[this.conditionStack[this.conditionStack.length-1]].rules:this.conditions.INITIAL.rules},topState:function(t){return(t=this.conditionStack.length-1-Math.abs(t||0))>=0?this.conditionStack[t]:"INITIAL"},pushState:function(t){this.begin(t)},stateStackSize:function(){return this.conditionStack.length},options:{},performAction:function(t,e,n,s){switch(n){case 0:case 1:break;case 2:return 59;case 3:return 60;case 4:return 58;case 5:return 61;case 6:return 12;case 7:return 70;case 8:return 63;case 9:return 9;case 10:return 22;case 11:return 25;case 12:return 43;case 13:return 64;case 14:return 65;case 15:return 29;case 16:return 66;case 17:return 62;case 18:return 46;case 19:return 80;case 20:return 79;case 21:return 23;case 22:return 24;case 23:return 26;case 24:return 28;case 25:return 40;case 26:return 41;case 27:return 16;case 28:return"|";case 29:return 14;case 30:return 54;case 31:return 5;case 32:return 18;case 33:return 11;case 34:return"<=";case 35:return 56;case 36:return 75;case 37:return 38;case 38:return"_";case 39:return 31;case 40:return 32;case 41:return 33;case 42:return 34;case 43:return 47;case 44:return 10}},rules:[/^(?:\s+)/,/^(?:\/\/.*)/,/^(?:any\b)/,/^(?:array\b)/,/^(?:as\b)/,/^(?:boolean\b)/,/^(?:def\b)/,/^(?:enum\b)/,/^(?:false\b)/,/^(?:let\b)/,/^(?:map\b)/,/^(?:patterns\b)/,/^(?:null\b)/,/^(?:number\b)/,/^(?:object\b)/,/^(?:sequences\b)/,/^(?:string\b)/,/^(?:true\b)/,/^(?:undefined\b)/,/^(?:[-+]?(0|[1-9]\d*)(\.\d+)?)/,/^(?:"[^"\r\n]*")/,/^(?:\()/,/^(?:\))/,/^(?:{)/,/^(?:})/,/^(?:\[)/,/^(?:\])/,/^(?:\|>)/,/^(?:\|)/,/^(?:,)/,/^(?::)/,/^(?:;)/,/^(?:=~)/,/^(?:=)/,/^(?:<=)/,/^(?:\.{3})/,/^(?:\.{2})/,/^(?:\.)/,/^(?:_)/,/^(?:\+)/,/^(?:-)/,/^(?:\*)/,/^(?:\/)/,/^(?:\$)/,/^(?:[a-zA-Z_][a-zA-Z0-9_]*)/],conditions:{INITIAL:{rules:[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44],inclusive:!0}}};function et(){this.yy={}}return K.lexer=tt,et.prototype=K,K.Parser=et,new et}();function y(t){switch(t){case null:return"null";case void 0:return"undefined";default:return Array.isArray(t)?"array":typeof t}}function p(t){return Array.isArray(t)?t.length:0}function d(t,e){const n=[];if(Array.isArray(t)&&t.length>0&&t.every(t=>Array.isArray(t))){const s=Math.max(...t.map(t=>t.length));for(let r=0;r<s;r++){const s=[];for(const n of t)s.push(r<n.length?n[r]:e);n.push(s)}}return n}function x(t,e,n,s){const{length:r}=t,i=[];n=void 0===n?e:n,e=Math.max(1,e),n=Math.max(1,n);for(let a=0;a<r;a+=n){const n=[];let o=a;for(let i=0;i<e;i++,o++)n.push(o<r?t[o]:s);i.push(n)}return i}function m(t){return Array.isArray(t)?t.slice().reverse():void 0}function f(t,e){return Array.isArray(t)?t.slice().sort(e):void 0}function b(t,e){return t.join(e)}function g(t){return null!==t&&"object"===typeof t}function w(t){return g(t)?Object.keys(t):[]}function v(t){return g(t)?Object.values(t):[]}function E(t){return g(t)?Object.entries(t):[]}function P(t){const e={};if(Array.isArray(t))for(const n of t)if(n.length>=2){const[t,s]=n;e[t]=s}return e}function k(...t){return t.length>0&&Array.isArray(t[0])?t[0].concat(...t.slice(1)):t.every(t=>g(t))?Object.assign({},...t):void 0}const M={};function O(t){return null!==t&&"object"===typeof t}class j{constructor(t,e){this.type=t,this.text=e}typeis(t){return this.type===t}}j.UNDEFINED=0,j.COMMAND=1,j.NUMBER=2,j.EOD=3;var A=j;var T=class{constructor(t){null!==t&&void 0!==t||(t=""),this.setPathData(t)}setPathData(t){if("string"!==typeof t)throw new TypeError("The first parameter must be a string");this._pathData=t}getNextToken(){let t=null,e=this._pathData;for(;null===t;)if(null===e||""===e)t=new A(A.EOD,"");else if(e.match(/^([ \t\r\n,]+)/))e=e.substr(RegExp.$1.length);else if(e.match(/^([AaCcHhLlMmQqSsTtVvZz])/))t=new A(A.COMMAND,RegExp.$1),e=e.substr(RegExp.$1.length);else{if(!e.match(/^(([-+]?\d+(\.\d*)?|[-+]?\.\d+)([eE][-+]?\d+)?)/))throw new SyntaxError(`Unrecognized path data: ${e}`);t=new A(A.NUMBER,RegExp.$1),e=e.substr(RegExp.$1.length)}return this._pathData=e,t}};const R="BOP";class N{constructor(){this._lexer=new T,this._handler=null}parseData(t){if("string"!==typeof t)throw new TypeError(`The first parameter must be a string: ${t}`);null!==this._handler&&"function"===typeof this._handler.beginParse&&this._handler.beginParse();const e=this._lexer;e.setPathData(t);let n=R,s=null,r=e.getNextToken();for(;!1===r.typeis(A.EOD);){let t;const i=[];switch(r.type){case A.COMMAND:if(n===R&&"M"!==r.text&&"m"!==r.text)throw new SyntaxError(`New paths must begin with a moveto command. Found '${r.text}'`);n=r.text,t=N.PARAMCOUNT[r.text.toUpperCase()],r=e.getNextToken();break;case A.NUMBER:if(n===R)throw new SyntaxError(`New paths must begin with a moveto command. Found '${r.text}'`);t=N.PARAMCOUNT[n.toUpperCase()];break;default:throw new SyntaxError(`Unrecognized command type: ${r.type}`)}for(let n=0;n<t;n++){switch(r.type){case A.COMMAND:throw new SyntaxError(`Parameter must be a number. Found '${r.text}'`);case A.NUMBER:i[n]=parseFloat(r.text);break;case A.EOD:throw new SyntaxError("Unexpected end of string");default:throw new SyntaxError(`Unrecognized parameter type. Found type '${r.type}'`)}r=e.getNextToken()}if(null!==this._handler){const t=this._handler,e=N.METHODNAME[n];"a"!==n&&"A"!==n||(i[3]=0!==i[3],i[4]=0!==i[4]),null!==t&&"function"===typeof t[e]&&t[e](...i)}switch(n){case"M":n="L";break;case"m":n="l";break;case"Z":case"z":n="BOP"}if(r===s)throw new SyntaxError(`Parser stalled on '${r.text}'`);s=r}null!==this._handler&&"function"===typeof this._handler.endParse&&this._handler.endParse()}setHandler(t){this._handler=t}}N.PARAMCOUNT={A:7,C:6,H:1,L:2,M:2,Q:4,S:4,T:2,V:1,Z:0},N.METHODNAME={A:"arcAbs",a:"arcRel",C:"curvetoCubicAbs",c:"curvetoCubicRel",H:"linetoHorizontalAbs",h:"linetoHorizontalRel",L:"linetoAbs",l:"linetoRel",M:"movetoAbs",m:"movetoRel",Q:"curvetoQuadraticAbs",q:"curvetoQuadraticRel",S:"curvetoCubicSmoothAbs",s:"curvetoCubicSmoothRel",T:"curvetoQuadraticSmoothAbs",t:"curvetoQuadraticSmoothRel",V:"linetoVerticalAbs",v:"linetoVerticalRel",Z:"closePath",z:"closePath"};var I=N;const _=2*Math.PI;function X(t,e,n,s,r,i,o){r=r*Math.PI/180;const c=Math.cos(r),h=Math.sin(r),u=t.subtract(e).multiply(.5),l=u.x*c+u.y*h,y=u.x*-h+u.y*c,p=l*l,d=y*y,x=p/((n=Math.abs(n))*n)+d/((s=Math.abs(s))*s);if(x>1){const t=Math.sqrt(x);n*=t,s*=t}const m=n*n,f=s*s,b=m*d,g=f*p;let w=(m*f-b-g)/(b+g);Math.abs(w)<1e-6&&(w=0);let v=Math.sqrt(w);i===o&&(v=-v);const E=t.add(e).multiply(.5),P=v*n*y/s,k=v*-s*l/n,M=(l-P)/n,O=(l+P)/n,j=(y-k)/s,A=(y+k)/s,T=new a(1,0).angleBetween(new a(M,j));let R=function(t){const e=t%_;return e<0?e+_:e}(new a(M,j).angleBetween(new a(-O,-A)));return!1===o&&(R-=_),[P*c-k*h+E.x,P*h+k*c+E.y,n,s,T,T+R]}var $=class{constructor(t){this.shapeCreator=t,this.shapes=[],this.firstX=null,this.firstY=null,this.lastX=null,this.lastY=null,this.lastCommand=null}beginParse(){this.shapes=[],this.firstX=null,this.firstY=null,this.lastX=null,this.lastY=null,this.lastCommand=null}addShape(t){this.shapes.push(t)}arcAbs(t,e,n,s,i,a,o){if(0===t||0===e)this.addShape(this.shapeCreator.line(this.lastX,this.lastY,a,o));else{const c=X(new r(this.lastX,this.lastY),new r(a,o),t,e,n,s,i);this.addShape(this.shapeCreator.arc(...c))}this.lastCommand="A",this.lastX=a,this.lastY=o}arcRel(t,e,n,s,i,a,o){if(0===t||0===e)this.addShape(this.shapeCreator.line(this.lastX,this.lastY,this.lastX+a,this.lastY+o));else{const c=X(new r(this.lastX,this.lastY),new r(this.lastX+a,this.lastY+o),t,e,n,s,i);this.addShape(this.shapeCreator.arc(...c))}this.lastCommand="a",this.lastX+=a,this.lastY+=o}curvetoCubicAbs(t,e,n,s,r,i){this.addShape(this.shapeCreator.cubicBezier(this.lastX,this.lastY,t,e,n,s,r,i)),this.lastX=r,this.lastY=i,this.lastCommand="C"}curvetoCubicRel(t,e,n,s,r,i){this.addShape(this.shapeCreator.cubicBezier(this.lastX,this.lastY,this.lastX+t,this.lastY+e,this.lastX+n,this.lastY+s,this.lastX+r,this.lastY+i)),this.lastX+=r,this.lastY+=i,this.lastCommand="c"}linetoHorizontalAbs(t){this.addShape(this.shapeCreator.line(this.lastX,this.lastY,t,this.lastY)),this.lastX=t,this.lastCommand="H"}linetoHorizontalRel(t){this.addShape(this.shapeCreator.line(this.lastX,this.lastY,this.lastX+t,this.lastY)),this.lastX+=t,this.lastCommand="h"}linetoAbs(t,e){this.addShape(this.shapeCreator.line(this.lastX,this.lastY,t,e)),this.lastX=t,this.lastY=e,this.lastCommand="L"}linetoRel(t,e){this.addShape(this.shapeCreator.line(this.lastX,this.lastY,this.lastX+t,this.lastY+e)),this.lastX+=t,this.lastY+=e,this.lastCommand="l"}movetoAbs(t,e){this.firstX=t,this.firstY=e,this.lastX=t,this.lastY=e,this.lastCommand="M"}movetoRel(t,e){this.firstX+=t,this.firstY+=e,this.lastX+=t,this.lastY+=e,this.lastCommand="m"}curvetoQuadraticAbs(t,e,n,s){this.addShape(this.shapeCreator.quadraticBezier(this.lastX,this.lastY,t,e,n,s)),this.lastX=n,this.lastY=s,this.lastCommand="Q"}curvetoQuadraticRel(t,e,n,s){this.addShape(this.shapeCreator.quadraticBezier(this.lastX,this.lastY,this.lastX+t,this.lastY+e,this.lastX+n,this.lastY+s)),this.lastX+=n,this.lastY+=s,this.lastCommand="q"}curvetoCubicSmoothAbs(t,e,n,s){let r,i;if(this.lastCommand.match(/^[SsCc]$/)){const t=this.shapes[this.shapes.length-1].args[2];r=2*this.lastX-t.x,i=2*this.lastY-t.y}else r=this.lastX,i=this.lastY;this.addShape(this.shapeCreator.cubicBezier(this.lastX,this.lastY,r,i,t,e,n,s)),this.lastX=n,this.lastY=s,this.lastCommand="S"}curvetoCubicSmoothRel(t,e,n,s){let r,i;if(this.lastCommand.match(/^[SsCc]$/)){const t=this.shapes[this.shapes.length-1].args[2];r=2*this.lastX-t.x,i=2*this.lastY-t.y}else r=this.lastX,i=this.lastY;this.addShape(this.shapeCreator.cubicBezier(this.lastX,this.lastY,r,i,this.lastX+t,this.lastY+e,this.lastX+n,this.lastY+s)),this.lastX+=n,this.lastY+=s,this.lastCommand="s"}curvetoQuadraticSmoothAbs(t,e){let n,s;if(this.lastCommand.match(/^[QqTt]$/)){const t=this.shapes[this.shapes.length-1].args[1];n=2*this.lastX-t.x,s=2*this.lastY-t.y}else n=this.lastX,s=this.lastY;this.addShape(this.shapeCreator.quadraticBezier(this.lastX,this.lastY,n,s,t,e)),this.lastX=t,this.lastY=e,this.lastCommand="T"}curvetoQuadraticSmoothRel(t,e){let n,s;if(this.lastCommand.match(/^[QqTt]$/)){const t=this.shapes[this.shapes.length-1].args[1];n=2*this.lastX-t.x,s=2*this.lastY-t.y}else n=this.lastX,s=this.lastY;this.addShape(this.shapeCreator.quadraticBezier(this.lastX,this.lastY,n,s,this.lastX+t,this.lastY+e)),this.lastX+=t,this.lastY+=e,this.lastCommand="t"}linetoVerticalAbs(t){this.addShape(this.shapeCreator.line(this.lastX,this.lastY,this.lastX,t)),this.lastY=t,this.lastCommand="V"}linetoVerticalRel(t){this.addShape(this.shapeCreator.line(this.lastX,this.lastY,this.lastX,this.lastY+t)),this.lastY+=t,this.lastCommand="v"}closePath(){this.addShape(this.shapeCreator.line(this.lastX,this.lastY,this.firstX,this.firstY)),this.lastX=this.firstX,this.lastY=this.firstY,this.lastCommand="z"}};const C=.5*Math.PI;class Y{constructor(t,e){this.name=t,this.args=e}static arc(...t){return L(Y.ARC,t,["center","radiusX","radiusY","startRadians","endRadians"])}static quadraticBezier(...t){return L(Y.QUADRATIC_BEZIER,t,["p1","p2","p3"])}static cubicBezier(...t){return L(Y.CUBIC_BEZIER,t,["p1","p2","p3","p4"])}static circle(...t){return L(Y.CIRCLE,t,["center","radius"])}static ellipse(...t){return L(Y.ELLIPSE,t,["center","radiusX","radiusY"])}static line(...t){return L(Y.LINE,t,["p1","p2"])}static path(...t){return L(Y.PATH,t,["segments"])}static polygon(...t){return L(Y.POLYGON,t,["points"])}static polyline(...t){return L(Y.POLYLINE,t,["points"])}static rectangle(...t){const e=L(Y.RECTANGLE,t,["topLeft","bottomRight","rx","ry"]);let n=e.args.pop(),s=e.args.pop();if(n=void 0===n?0:n,0===(s=void 0===s?0:s)&&0===n)return e;const{x:r,y:i}=e.args[0],{x:a,y:o}=e.args[1],c=a-r,h=o-i;0===s&&(s=n),0===n&&(n=s),s>.5*c&&(s=.5*c),n>.5*h&&(n=.5*h);const u=r,l=i,y=r+s,p=i+n,d=a-s,x=o-n,m=a,f=o,b=[Y.arc(y,p,s,n,2*C,3*C),Y.line(y,l,d,l),Y.arc(d,p,s,n,3*C,4*C),Y.line(m,p,m,x),Y.arc(d,x,s,n,0,C),Y.line(d,f,y,f),Y.arc(y,x,s,n,C,2*C),Y.line(u,x,u,p)];return new Y(Y.PATH,b)}}function L(t,e,n){let s;1===e.length?(e=e[0],s=Array.isArray(e)||"string"===typeof e?t+"Args":t):s=t+"Args";const r=S.execute(s,e);if(r===M)throw new TypeError(`${t} is not in a recognizable format: ${JSON.stringify(e)}`);const i=1===n.length?r[n[0]]:n.map(t=>r[t]);return new Y(t,i)}Y.ARC="Arc",Y.QUADRATIC_BEZIER="Bezier2",Y.CUBIC_BEZIER="Bezier3",Y.CIRCLE="Circle",Y.ELLIPSE="Ellipse",Y.LINE="Line",Y.PATH="Path",Y.POLYGON="Polygon",Y.POLYLINE="Polyline",Y.RECTANGLE="Rectangle";const S=new class{constructor(){this.symbolTable={},this.functions={},this.messages=[],this.verbose=!1;for(const t in s)this.functions[t]=s[t]}addFunction(t,e){this.functions[t]=e}addInfo(t){this.verbose&&this.messages.push({type:"message",level:"info",message:t})}addWarning(t){this.messages.push({type:"message",level:"warning",message:t})}addError(t){this.messages.push({type:"message",level:"error",message:t})}execute(t,e){const n=l.parse(t);let s;this.messages=[];for(const r of n)switch(r.type){case"assignment":case"def":case"sequence":s=this.executeExpression(r,e,this.symbolTable);break;default:return this.addError(`unknown statement type: ${r.type}`),M}return s}executeExpression(t,e,n){const s=s=>{const r=this.executeExpression(t.left,e,n);if(r!==M&&"number"===typeof r){const i=this.executeExpression(t.right,e,n);if(i!==M&&"number"===typeof i)return s(r,i)}return M};switch(t.type){case"assignment":{const s=this.executeExpression(t.value,e,n);return s===M?(this.addError(`Unable to evaluate assignment value for ${t.name}`),M):(n[t.name]=s,s)}case"def":return void(n[t.name]=t.value);case"get-value":if(t.name in n){const s=n[t.name];if(O(s)&&"sequence"===s.type){const r=this.executeExpression(s,e,n);return r===M?(this.addError(`Unable to evaluate sequence ${t.name}`),M):r}return s}return t.name in this.functions?this.invokeFunction(t.name,[e]):(this.addError(`Tried to access unbound symbol: ${t.name}`),M);case"get-property":{const s=this.executeExpression(t.left,e,n);return O(s)?s[t.right]:M}case"get-index":{const{left:s,right:r}=t,i=this.executeExpression(s,e,n);if(Array.isArray(i)){const t=r<0?i.length+r:r;return 0<=t&&t<i.length?i[t]:M}return M}case"get-structure":return e;case"sequences":{let s=M;for(const r of t.sequences){const t=Object.create(n);if((s=this.executeExpression(r,e,t))!==M){Object.assign(n,t);break}}return s}case"sequence":{let s=e;for(const e of t.steps)if((s="pattern"===e.type?this.executePattern(e,s,n):this.executeExpression(e,s,n))===M)return M;return s}case"add":return s((t,e)=>t+e);case"map":{const[s,r]=t.value,i=this.executeExpression(s,e,n);if(i!==M){if(!1===Array.isArray(i))return this.addError("First argument of map must evaluate to an array"),M;const t=Object.create(n);return i.map(e=>this.executeExpression(r,e,t))}return M}case"patterns":{let s=M;for(const r of t.patterns){const t=Object.create(n);if((s=this.executePattern(r,e,t))!==M){Object.assign(n,t);break}}return s}case"subtract":return s((t,e)=>t-e);case"multiply":return s((t,e)=>t*e);case"divide":return s((t,e)=>t/e);case"invoke":{const s=t.args.reduce((t,s)=>{if("spread"===s.type){const r=this.executeExpression(s.expression,e,n);Array.isArray(r)?t=t.concat(r):t.push(r)}else t.push(this.executeExpression(s,e,n));return t},[]);return t.name in this.functions?this.invokeFunction(t.name,s):(this.addError(`Tried to access unbound symbol: ${t.name}`),M)}case"array":{const s=[];for(const r of t.value)if("assignment"===r.type)this.executeExpression(r,e,n);else{const t=this.executeExpression(r,e,n);if(t===M)return M;s.push(t)}return s}case"boolean":case"null":case"number":case"string":case"undefined":return t.value;case"object":return this.executeObjectExpression(t,e,n);default:return this.addError(`Unrecognized expression type: '${t.type}'`),M}}executeObjectExpression(t,e,n){const s=Object.create(n),r={};for(const i of t.value)switch(i.type){case"property":{const t=this.executeExpression(i.name,e,s);if(t===M)return M;if("string"!==typeof t)return this.addError(`Property names must be string types: ${t}`),M;const a=null!==i.value?this.executeExpression(i.value,e,s):n[t];if(a===M)return this.addError(`Unable to evaluate value for property ${t}`),M;r[t]=a;break}case"assignment":if(this.executeExpression(i,e,s)===M)return M;break;default:return this.addError(`Unrecognized object expression element type: ${i.type}`),M}return r}executePattern(t,e,n){switch(t.patternType){case"any":return this.assign(n,t.assignTo,e),e;case"array":return Array.isArray(e)?(this.assign(n,t.assignTo,e),e):M;case"array-pattern":return this.executeArrayPattern(t,e,n)===M?M:n;case"boolean":return"boolean"!==typeof e||null!==t.value&&t.value!==e?M:(this.assign(n,t.assignTo,e),e);case"null":return null===e?(this.assign(n,t.assignTo,e),e):M;case"number":return"number"!==typeof e||null!==t.value&&t.value!==e?M:(this.assign(n,t.assignTo,e),e);case"object":return O(e)?(this.assign(n,t.assignTo,e),e):M;case"object-pattern":{if(!1===O(e))return M;const s={};for(const r of t.value){const{name:t,pattern:i,assignTo:a}=r;if(!(t in e))return M;{const r=this.executePattern(i,e[t],n);if(r===M)return M;this.assign(n,a,e[t]),this.assign(s,a,r)}}return this.assign(n,t.assignTo,e),s}case"reference":if(t.value in this.patterns){const s=this.patterns[t.value],r=this.executePattern(s,e,n);return r!==M&&this.assign(n,t.assignTo,r),r}return M;case"string":return"string"!==typeof e||null!==t.value&&t.value!==e?M:(this.assign(n,t.assignTo,e),e);case"undefined":return void 0===e?(this.assign(n,t.assignTo,e),e):M;default:throw new TypeError(`unrecognized pattern type: '${t.type}'`)}}executeArrayPattern(t,e,n){if(!1===Array.isArray(e))return M;let s=[],r=0;for(const i of t.value){const t=this.executeArrayPatternElement(i,r,e,n);if(t===M)return M;s=s.concat(t),r+=t.length}return r===e.length?(this.assign(n,t.assignTo,e),s):M}executeArrayPatternElement(t,e,n,s){let r=[];switch(t.type){case"element":{const i=this.executeArrayElementPattern(t,e,n,s);if(i===M)return M;r=r.concat(i),e+=i.length;break}case"element-group":{const i=this.executeArrayElementGroupPattern(t,e,n,s);if(i===M)return M;r=r.concat(i),e+=i.length;break}default:return this.addError(`Unrecognized array pattern element type: '${t.type}'`),M}return r}executeArrayElementPattern(t,e,n,s){const{pattern:r,range:{start:i,stop:a}}=t,o=[];for(let c=0;c<a;c++){const h=e+c,u=h<n.length?this.executePattern(r,n[h],s):M;if(u===M){if(c>=i)break;return M}a>1?this.pushAssign(s,t.assignTo,u):this.assign(s,t.assignTo,u),o.push(u)}return o}executeArrayElementGroupPattern(t,e,n,s){const{elements:r,range:{start:i,stop:a}}=t;let o=[];for(let c=0;c<a;c++){let h=[];for(const t of r){const r=Object.create(s),i=this.executeArrayPatternElement(t,e,n,r);if(i===M){h=M;break}null!==t.assignTo&&void 0!==t.assignTo&&t.assignTo in r&&(a>1?this.pushAssign(s,t.assignTo,r[t.assignTo]):this.assign(s,t.assignTo,r[t.assignTo])),o=o.concat(i),e+=i.length,h=h.concat(i)}if(h===M){if(c>=i){if(0===c){this.assign(s,t.assignTo,[]);for(const t of r)this.assign(s,t.assignTo,[])}return o}return M}a>1?this.pushAssign(s,t.assignTo,h):this.assign(s,t.assignTo,h)}return o}invokeFunction(t,e){return t in this.functions?this.functions[t](...e):M}assign(t,e,n){null!==e&&void 0!==e&&(t.hasOwnProperty(e)&&this.addWarning(`Overwriting ${e} with value: ${n}`),t[e]=n)}pushAssign(t,e,n){if(null!==e&&void 0!==e){const s=t.hasOwnProperty(e)?t[e]:[];Array.isArray(s)?(s.push(n),t[e]=s):this.addWarning(`Unable to push to ${e} because it is not an array: ${s}`)}}};S.execute('\ndef Center =\n    patterns {\n        { center: { x: number as x, y: number as y } },\n        { center: [ number as x, number as y ] },\n        { cx: number as x, cy: number as y },\n        { centerX: number as x, centerY: number as y }\n    } |> Point2D(x, y);\n\ndef Radii =\n    patterns {\n        { radii: { x: number as rx, y: number as ry } },\n        { radii: [ number as rx, number as ry ] },\n        { rx: number as rx, ry: number as ry },\n        { radiusX: number as rx, radiusY: number as ry }\n    } |> { "rx", "ry" };\n\ndef P1 =\n    patterns {\n        { p1: { x: number as x, y: number as y } },\n        { p1: [ number as x, number as y ] },\n        { p1x: number as x, p1y: number as y }\n    } |> Point2D(x, y);\n        \ndef P2 =\n    patterns {\n        { p1: { x: number as x, y: number as y } },\n        { p1: [ number as x, number as y ] },\n        { p1x: number as x, p1y: number as y }\n    } |> Point2D(x, y);\n        \ndef P3 =\n    patterns {\n        { p1: { x: number as x, y: number as y } },\n        { p1: [ number as x, number as y ] },\n        { p1x: number as x, p1y: number as y }\n    } |> Point2D(x, y);\n        \ndef P4 =\n    patterns {\n        { p1: { x: number as x, y: number as y } },\n        { p1: [ number as x, number as y ] },\n        { p1x: number as x, p1y: number as y }\n    } |> Point2D(x, y);\n\n            \ndef Arc = {\n    let radii = Radii,\n\n    "center": Center,\n    "radiusX": radii.rx,\n    "radiusY": radii.ry,\n    "startRadians": =~ number,\n    "endRadians": =~ number\n};\n\ndef ArcArgs = {\n    let elements =\n        patterns {\n            [ number as centerX, number as centerY, number as radiusX, number as radiusY, number as startRadians, number as endRadians ],\n            [ { x: number as centerX, y: number as centerY }, number as radiusX, number as radiusY, number as startRadians, number as endRadians ]\n        } |> { "centerX", "centerY", "radiusX", "radiusY", "startRadians", "endRadians" },\n    \n    "center": Point2D(elements.centerX, elements.centerY),\n    "radiusX": elements.radiusX,\n    "radiusY": elements.radiusY,\n    "startRadians": elements.startRadians,\n    "endRadians": elements.endRadians\n};\n\ndef Bezier2 = {\n    "p1": P1,\n    "p2": P2,\n    "p3": P3\n};\n\ndef Bezier2Args = {\n    let elements =\n        patterns {\n            [ number as p1x, number as p1y, number as p2x, number as p2y, number as p3x, number as p3y ],\n            [ { x: number as p1x, y: number as p1y }, { x: number as p2x, y: number as p2y }, { x: number as p3x, y: number as p3y }]\n        } |> { "p1x", "p1y", "p2x", "p2y", "p3x", "p3y" },\n    \n    "p1": Point2D(elements.p1x, elements.p1y),\n    "p2": Point2D(elements.p2x, elements.p2y),\n    "p3": Point2D(elements.p3x, elements.p3y)\n};\n\ndef Bezier3 = {\n    "p1": P1,\n    "p2": P2,\n    "p3": P3,\n    "p4": P4\n};\n\ndef Bezier3Args = {\n    let elements =\n        patterns {\n            [ number as p1x, number as p1y, number as p2x, number as p2y, number as p3x, number as p3y, number as p4x, number as p4y ],\n            [ { x: number as p1x, y: number as p1y }, { x: number as p2x, y: number as p2y }, { x: number as p3x, y: number as p3y }, { x: number as p4x, y: number as p4y }]\n        } |> { "p1x", "p1y", "p2x", "p2y", "p3x", "p3y", "p4x", "p4y" },\n    \n    "p1": Point2D(elements.p1x, elements.p1y),\n    "p2": Point2D(elements.p2x, elements.p2y),\n    "p3": Point2D(elements.p3x, elements.p3y),\n    "p4": Point2D(elements.p4x, elements.p4y)\n};\n\ndef Circle = {\n    "center": Center,\n    "radius":\n        patterns {\n            { r: number as radius},\n            { radius: number as radius }\n        } |> radius\n};\n\ndef CircleArgs = {\n    let elements =\n        patterns {\n            [ number as centerX, number as centerY, number as radius ],\n            [ { x: number as centerX, y: number as centerY }, number as radius ]\n        } |> { "centerX", "centerY", "radius" },\n    \n    "center": Point2D(elements.centerX, elements.centerY),\n    "radius": elements.radius\n};\n\ndef Ellipse = {\n    let radii = Radii,\n\n    "center": Center,\n    "radiusX": radii.rx,\n    "radiusY": radii.ry\n};\n\ndef EllipseArgs = {\n    let elements =\n       patterns {\n            [ number as centerX, number as centerY, number as radiusX, number as radiusY ],\n            [ { x: number as centerX, y: number as centerY }, number as radiusX, number as radiusY ]\n        } |> { "centerX", "centerY", "radiusX", "radiusY" },\n    \n    "center": Point2D(elements.centerX, elements.centerY),\n    "radiusX": elements.radiusX,\n    "radiusY": elements.radiusY\n};\n\ndef Line = {\n    "p1": P1,\n    "p2": P2\n};\n\ndef LineArgs = {\n    let elements =\n        patterns {\n            [ number as p1x, number as p1y, number as p2x, number as p2y ],\n            [ { x: number as p1x, y: number as p1y }, { x: number as p2x, y: number as p2y } ]\n        } |> { "p1x", "p1y", "p2x", "p2y" },\n        \n    "p1": Point2D(elements.p1x, elements.p1y),\n    "p2": Point2D(elements.p2x, elements.p2y)\n};\n\ndef Path = {\n    "segments":\n        =~ { d: string as data } |> PathData(data)\n};\n\ndef PathArgs = {\n    "segments":\n        =~ string as data |> PathData(data)\n};\n\ndef Polygon = {\n    "points":\n        sequences {\n            =~ { points: [ (number, number); 0.. as coords ] }\n            |> [ map(coords, Point2D(...$)) ],\n\n            =~ { points: [ { x: number, y: number }; 0.. ] as points }\n            |> [ map(points, Point2D($.x, $.y)) ]\n        }\n};\n\ndef PolygonArgs = {\n    "points":\n        sequences {\n            =~ [ (number, number); 0.. as coords ]\n            |> [ map(coords, Point2D(...$)) ],\n\n            =~ [ { x: number, y: number }; 0.. ] as points\n            |> [ map(points, Point2D($.x, $.y)) ]\n        }\n};\n\ndef Polyline = {\n    "points":\n        sequences {\n            =~ { points: [ (number, number); 0.. as coords ] }\n            |> [ map(coords, Point2D(...$)) ],\n\n            =~ { points: [ { x: number, y: number }; 0.. ] as points }\n            |> [ map(points, Point2D($.x, $.y)) ]\n        }\n};\n\ndef PolylineArgs = {\n    "points":\n        sequences {\n            =~ [ (number, number); 0.. as coords ]\n            |> [ map(coords, Point2D(...$)) ],\n\n            =~ [ { x: number, y: number }; 0.. ] as points\n            |> [ map(points, Point2D($.x, $.y)) ]\n        }\n};\n\ndef Rectangle = {\n    let topLeft =\n        patterns {\n            { topLeft: { x: number as x, y: number as y } },\n            { topLeft: [ number as x, number as y ] },\n            { x: number as x, y: number as y },\n            { top: number as x, left: number as y }\n        } |> { "x", "y" },\n\n    "topLeft":\n        Point2D(topLeft.x, topLeft.y),\n\n    "bottomRight":\n        sequences {\n            patterns {\n                { bottomRight: { x: number as x, y: number as y } },\n                { bottomRight: [ number as x, number as y ] }\n            } |> Point2D(x, y),\n            patterns {\n                { w: number as w, h: number as h },\n                { width: number as w, height: number as h },\n                { size: { x: number as w, y: number as h } },\n                { size: [ number as w, number as h ] }\n            } |> Point2D(topLeft.x + w, topLeft.y + h)\n        },\n\n    "rx":\n        sequences {\n            =~ { rx: number as rx } |> rx,\n            =~ any |> 0\n        },\n    "ry":\n        sequences {\n            =~ { ry: number as ry } |> ry,\n            =~ any |> 0\n        }\n};\n\ndef RectangleArgs = {\n    let elements =\n        patterns {\n            [ number as x, number as y, number as width, number as height ],\n            [ number as x, number as y, number as width, number as height, number as rx, number as ry ],\n            [ { x: number as x, y: number as y }, { x: number as width, y: number as height } ],\n            [ { x: number as x, y: number as y }, { x: number as width, y: number as height }, { rx: number as rx, ry: number as ry } ],\n            [ { x: number as x, y: number as y }, { x: number as width, y: number as height }, { radiusX: number as rx, radiusY: number as ry } ]\n        } |> { "x", "y", "width", "height", "rx", "ry" },\n\n    "topLeft": Point2D(elements.x, elements.y),\n    "bottomRight": Point2D(elements.x + elements.width, elements.y + elements.height),\n    "rx": elements.rx,\n    "ry": elements.ry\n}\n'),S.addFunction("Point2D",(t,e)=>new r(t,e)),S.addFunction("PathData",t=>{const e=new I,n=new $(Y);return e.setHandler(n),e.parseData(t),n.shapes});const B=2*Math.PI,D=new a(1,0);function z(t){return null===t||void 0===t}function q(t){const e=t%B;return e<0?e+B:e}function F(t){const e=t.slice();return e.push(t[0]),e}class U{constructor(t){this.init(t)}init(t){this.status=t,this.points=[]}static intersect(t,e){let n;if(z(t)||z(e))n=new U("No Intersection");else if("Path"===t.name)n=U.intersectPathShape(t,e);else if("Path"===e.name)n=U.intersectPathShape(e,t);else if("Arc"===t.name)n=U.intersectArcShape(t,e);else if("Arc"===e.name)n=U.intersectArcShape(e,t);else{let s,r;if(t.name<e.name?(s="intersect"+t.name+e.name,r=t.args.concat(e.args)):(s="intersect"+e.name+t.name,r=e.args.concat(t.args)),!(s in U))throw new TypeError("Intersection not available: "+s);n=U[s].apply(null,r)}return n}static intersectPathShape(t,e){const n=new U("No Intersection");for(const s of t.args){const t=U.intersect(s,e);n.appendPoints(t.points)}return n.points.length>0&&(n.status="Intersection"),n}static intersectArcShape(t,e){const[n,s,r,i,o]=t.args,c=new Y(Y.ELLIPSE,[n,s,r]);return function(t,e,n,s,r,i){if(0===t.points.length)return t;const o=new U("No Intersection"),c=q(r);let h=q(i);h<c&&(h+=B);for(const u of t.points){const t=q(D.angleBetween(a.fromPoints(e,u)));c<=t&&t<=h&&o.appendPoint(u)}return o.points.length>0&&(o.status="Intersection"),o}(U.intersect(c,e),n,0,0,i,o)}static intersectBezier2Bezier2(t,e,n,s,i,a){let o,c;const h=new U("No Intersection");o=e.multiply(-2);const l=t.add(o.add(n));o=t.multiply(-2),c=e.multiply(2);const y=o.add(c),p=new r(t.x,t.y);o=i.multiply(-2);const d=s.add(o.add(a));o=s.multiply(-2),c=i.multiply(2);const x=o.add(c),m=new r(s.x,s.y);o=l.x*y.y-y.x*l.y,c=d.x*y.y-y.x*d.y;const f=x.x*y.y-y.x*x.y,b=y.x*(p.y-m.y)+y.y*(-p.x+m.x),g=d.x*l.y-l.x*d.y,w=x.x*l.y-l.x*x.y,v=l.x*(p.y-m.y)+l.y*(-p.x+m.x),E=new u(-g*g,-2*g*w,o*c-w*w-2*g*v,o*f-2*w*v,o*b-v*v).getRoots();for(const r of E)if(0<=r&&r<=1){const t=new u(l.x,y.x,p.x-m.x-r*x.x-r*r*d.x);t.simplifyEquals();const e=t.getRoots(),n=new u(l.y,y.y,p.y-m.y-r*x.y-r*r*d.y);n.simplifyEquals();const s=n.getRoots();if(e.length>0&&s.length>0){const t=1e-4;t:for(const n of e)if(0<=n&&n<=1)for(let e=0;e<s.length;e++)if(Math.abs(n-s[e])<t){h.points.push(d.multiply(r*r).add(x.multiply(r).add(m)));break t}}}return h.points.length>0&&(h.status="Intersection"),h}static intersectBezier2Bezier3(t,e,n,s,i,a,o){let c,h,l,y;const p=new U("No Intersection");c=e.multiply(-2);const d=t.add(c.add(n));c=t.multiply(-2),h=e.multiply(2);const x=c.add(h),m=new r(t.x,t.y);c=s.multiply(-1),h=i.multiply(3),l=a.multiply(-3),y=c.add(h.add(l.add(o)));const f=new r(y.x,y.y);c=s.multiply(3),h=i.multiply(-6),l=a.multiply(3),y=c.add(h.add(l));const b=new r(y.x,y.y);c=s.multiply(-3),h=i.multiply(3),l=c.add(h);const g=new r(l.x,l.y),w=new r(s.x,s.y),v=m.x*m.x,E=m.y*m.y,P=x.x*x.x,k=x.y*x.y,M=d.x*d.x,O=d.y*d.y,j=w.x*w.x,A=w.y*w.y,T=g.x*g.x,R=g.y*g.y,N=b.x*b.x,I=b.y*b.y,_=f.x*f.x,X=f.y*f.y,$=new u(-2*d.x*d.y*f.x*f.y+M*X+O*_,-2*d.x*d.y*b.x*f.y-2*d.x*d.y*b.y*f.x+2*O*b.x*f.x+2*M*b.y*f.y,-2*d.x*g.x*d.y*f.y-2*d.x*d.y*g.y*f.x-2*d.x*d.y*b.x*b.y+2*g.x*O*f.x+O*N+M*(2*g.y*f.y+I),2*m.x*d.x*d.y*f.y+2*m.y*d.x*d.y*f.x+x.x*x.y*d.x*f.y+x.x*x.y*d.y*f.x-2*w.x*d.x*d.y*f.y-2*d.x*w.y*d.y*f.x-2*d.x*g.x*d.y*b.y-2*d.x*d.y*g.y*b.x-2*m.x*O*f.x-2*m.y*M*f.y+2*w.x*O*f.x+2*g.x*O*b.x-k*d.x*f.x-P*d.y*f.y+M*(2*w.y*f.y+2*g.y*b.y),2*m.x*d.x*d.y*b.y+2*m.y*d.x*d.y*b.x+x.x*x.y*d.x*b.y+x.x*x.y*d.y*b.x-2*w.x*d.x*d.y*b.y-2*d.x*w.y*d.y*b.x-2*d.x*g.x*d.y*g.y-2*m.x*O*b.x-2*m.y*M*b.y+2*w.x*O*b.x-k*d.x*b.x-P*d.y*b.y+T*O+M*(2*w.y*b.y+R),2*m.x*d.x*d.y*g.y+2*m.y*d.x*g.x*d.y+x.x*x.y*d.x*g.y+x.x*x.y*g.x*d.y-2*w.x*d.x*d.y*g.y-2*d.x*w.y*g.x*d.y-2*m.x*g.x*O-2*m.y*M*g.y+2*w.x*g.x*O-k*d.x*g.x-P*d.y*g.y+2*M*w.y*g.y,-2*m.x*m.y*d.x*d.y-m.x*x.x*x.y*d.y-m.y*x.x*x.y*d.x+2*m.x*d.x*w.y*d.y+2*m.y*w.x*d.x*d.y+x.x*w.x*x.y*d.y+x.x*x.y*d.x*w.y-2*w.x*d.x*w.y*d.y-2*m.x*w.x*O+m.x*k*d.x+m.y*P*d.y-2*m.y*M*w.y-w.x*k*d.x-P*w.y*d.y+v*O+E*M+j*O+M*A).getRootsInInterval(0,1);for(const r of $){const t=new u(d.x,x.x,m.x-w.x-r*g.x-r*r*b.x-r*r*r*f.x).getRoots(),e=new u(d.y,x.y,m.y-w.y-r*g.y-r*r*b.y-r*r*r*f.y).getRoots();if(t.length>0&&e.length>0){const n=1e-4;t:for(const s of t)if(0<=s&&s<=1)for(let t=0;t<e.length;t++)if(Math.abs(s-e[t])<n){p.points.push(f.multiply(r*r*r).add(b.multiply(r*r).add(g.multiply(r).add(w))));break t}}}return p.points.length>0&&(p.status="Intersection"),p}static intersectBezier2Circle(t,e,n,s,r){return U.intersectBezier2Ellipse(t,e,n,s,r,r)}static intersectBezier2Ellipse(t,e,n,s,i,a){let o;const c=new U("No Intersection");o=e.multiply(-2);const h=t.add(o.add(n));o=t.multiply(-2);const l=e.multiply(2),y=o.add(l),p=new r(t.x,t.y),d=i*i,x=a*a,m=new u(x*h.x*h.x+d*h.y*h.y,2*(x*h.x*y.x+d*h.y*y.y),x*(2*h.x*p.x+y.x*y.x)+d*(2*h.y*p.y+y.y*y.y)-2*(x*s.x*h.x+d*s.y*h.y),2*(x*y.x*(p.x-s.x)+d*y.y*(p.y-s.y)),x*(p.x*p.x+s.x*s.x)+d*(p.y*p.y+s.y*s.y)-2*(x*s.x*p.x+d*s.y*p.y)-d*x).getRoots();for(const r of m)0<=r&&r<=1&&c.points.push(h.multiply(r*r).add(y.multiply(r).add(p)));return c.points.length>0&&(c.status="Intersection"),c}static intersectBezier2Line(t,e,n,s,i){let o;const c=s.min(i),h=s.max(i),l=new U("No Intersection");o=e.multiply(-2);const y=t.add(o.add(n));o=t.multiply(-2);const p=e.multiply(2),d=o.add(p),x=new r(t.x,t.y),m=new a(s.y-i.y,i.x-s.x),f=s.x*i.y-i.x*s.y,b=new u(m.dot(y),m.dot(d),m.dot(x)+f).getRoots();for(const r of b)if(0<=r&&r<=1){const a=t.lerp(e,r),o=e.lerp(n,r),u=a.lerp(o,r);s.x===i.x?c.y<=u.y&&u.y<=h.y&&(l.status="Intersection",l.appendPoint(u)):s.y===i.y?c.x<=u.x&&u.x<=h.x&&(l.status="Intersection",l.appendPoint(u)):c.x<=u.x&&u.x<=h.x&&c.y<=u.y&&u.y<=h.y&&(l.status="Intersection",l.appendPoint(u))}return l}static intersectBezier2Polygon(t,e,n,s){return U.intersectBezier2Polyline(t,e,n,F(s))}static intersectBezier2Polyline(t,e,n,s){const r=new U("No Intersection"),{length:i}=s;for(let a=0;a<i-1;a++){const i=s[a],o=s[a+1],c=U.intersectBezier2Line(t,e,n,i,o);r.appendPoints(c.points)}return r.points.length>0&&(r.status="Intersection"),r}static intersectBezier2Rectangle(t,e,n,s,i){const a=s.min(i),o=s.max(i),c=new r(o.x,a.y),h=new r(a.x,o.y),u=U.intersectBezier2Line(t,e,n,a,c),l=U.intersectBezier2Line(t,e,n,c,o),y=U.intersectBezier2Line(t,e,n,o,h),p=U.intersectBezier2Line(t,e,n,h,a),d=new U("No Intersection");return d.appendPoints(u.points),d.appendPoints(l.points),d.appendPoints(y.points),d.appendPoints(p.points),d.points.length>0&&(d.status="Intersection"),d}static intersectBezier3Bezier3(t,e,n,s,i,a,o,c){let h,l,y,p;const d=new U("No Intersection");h=t.multiply(-1),l=e.multiply(3),y=n.multiply(-3),p=h.add(l.add(y.add(s)));const x=new r(p.x,p.y);h=t.multiply(3),l=e.multiply(-6),y=n.multiply(3),p=h.add(l.add(y));const m=new r(p.x,p.y);h=t.multiply(-3),l=e.multiply(3),y=h.add(l);const f=new r(y.x,y.y),b=new r(t.x,t.y);h=i.multiply(-1),l=a.multiply(3),y=o.multiply(-3),p=h.add(l.add(y.add(c)));const g=new r(p.x,p.y);h=i.multiply(3),l=a.multiply(-6),y=o.multiply(3),p=h.add(l.add(y));const w=new r(p.x,p.y);h=i.multiply(-3),l=a.multiply(3),y=h.add(l);const v=new r(y.x,y.y),E=new r(i.x,i.y);h=x.x*m.y-m.x*x.y,l=x.x*f.y-f.x*x.y;const P=x.x*b.y-b.x*x.y+E.x*x.y-x.x*E.y,k=v.x*x.y-x.x*v.y,M=w.x*x.y-x.x*w.y,O=g.x*x.y-x.x*g.y;p=x.x*f.y-f.x*x.y;const j=x.x*b.y+m.x*f.y-f.x*m.y-b.x*x.y+E.x*x.y-x.x*E.y,A=v.x*x.y-x.x*v.y,T=w.x*x.y-x.x*w.y,R=g.x*x.y-x.x*g.y,N=m.x*b.y-b.x*m.y+E.x*m.y-m.x*E.y,I=v.x*m.y-m.x*v.y,_=w.x*m.y-m.x*w.y,X=g.x*m.y-m.x*g.y,$=x.x*b.y-b.x*x.y+E.x*x.y-x.x*E.y,C=v.x*x.y-x.x*v.y,Y=w.x*x.y-x.x*w.y,L=g.x*x.y-x.x*g.y,S=m.x*b.y-b.x*m.y+E.x*m.y-m.x*E.y,B=v.x*m.y-m.x*v.y,D=w.x*m.y-m.x*w.y,z=g.x*m.y-m.x*g.y,q=f.x*b.y-b.x*f.y+E.x*f.y-f.x*E.y,F=v.x*f.y-f.x*v.y,Q=w.x*f.y-f.x*w.y,W=g.x*f.y-f.x*g.y,Z=new u(-O*R*L,-O*R*Y-O*T*L-M*R*L,-O*R*C-O*T*Y-M*R*Y-O*A*L-M*T*L-k*R*L,-O*R*$-O*T*C-M*R*C-O*A*Y-M*T*Y-k*R*Y-O*j*L-M*A*L-k*T*L-P*R*L+l*X*L+O*p*z-h*X*z+h*R*W,-O*T*$-M*R*$-O*A*C-M*T*C-k*R*C-O*j*Y-M*A*Y-k*T*Y-P*R*Y+l*X*Y-M*j*L-k*A*L-P*T*L+l*_*L+O*p*D-h*X*D+M*p*z-h*_*z+h*R*Q+h*T*W,-O*A*$-M*T*$-k*R*$-O*j*C-M*A*C-k*T*C-P*R*C+l*X*C-M*j*Y-k*A*Y-P*T*Y+l*_*Y-k*j*L-P*A*L+l*I*L+O*p*B-h*X*B+M*p*D-h*_*D+k*p*z-h*I*z+h*R*F+h*T*Q+h*A*W,-O*j*$-M*A*$-k*T*$-P*R*$+l*X*$-M*j*C-k*A*C-P*T*C+l*_*C-k*j*Y-P*A*Y+l*I*Y-P*j*L+l*N*L+O*p*S-h*X*S+M*p*B-h*_*B+k*p*D-h*I*D+P*p*z-h*N*z+h*R*q+h*T*F+h*A*Q-l*p*W+h*j*W,-M*j*$-k*A*$-P*T*$+l*_*$-k*j*C-P*A*C+l*I*C-P*j*Y+l*N*Y+M*p*S-h*_*S+k*p*B-h*I*B+P*p*D-h*N*D+h*T*q+h*A*F-l*p*Q+h*j*Q,-k*j*$-P*A*$+l*I*$-P*j*C+l*N*C+k*p*S-h*I*S+P*p*B-h*N*B+h*A*q-l*p*F+h*j*F,-P*j*$+l*N*$+P*p*S-h*N*S-l*p*q+h*j*q);Z.simplifyEquals();const G=Z.getRootsInInterval(0,1);for(const r of G){const t=new u(x.x,m.x,f.x,b.x-E.x-r*v.x-r*r*w.x-r*r*r*g.x);t.simplifyEquals();const e=t.getRoots(),n=new u(x.y,m.y,f.y,b.y-E.y-r*v.y-r*r*w.y-r*r*r*g.y);n.simplifyEquals();const s=n.getRoots();if(e.length>0&&s.length>0){const t=1e-4;t:for(const n of e)if(0<=n&&n<=1)for(let e=0;e<s.length;e++)if(Math.abs(n-s[e])<t){d.points.push(g.multiply(r*r*r).add(w.multiply(r*r).add(v.multiply(r).add(E))));break t}}}return d.points.length>0&&(d.status="Intersection"),d}static intersectBezier3Circle(t,e,n,s,r,i){return U.intersectBezier3Ellipse(t,e,n,s,r,i,i)}static intersectBezier3Ellipse(t,e,n,s,i,a,o){let c,h,l,y;const p=new U("No Intersection");c=t.multiply(-1),h=e.multiply(3),l=n.multiply(-3),y=c.add(h.add(l.add(s)));const d=new r(y.x,y.y);c=t.multiply(3),h=e.multiply(-6),l=n.multiply(3),y=c.add(h.add(l));const x=new r(y.x,y.y);c=t.multiply(-3),h=e.multiply(3),l=c.add(h);const m=new r(l.x,l.y),f=new r(t.x,t.y),b=a*a,g=o*o,w=new u(d.x*d.x*g+d.y*d.y*b,2*(d.x*x.x*g+d.y*x.y*b),2*(d.x*m.x*g+d.y*m.y*b)+x.x*x.x*g+x.y*x.y*b,2*d.x*g*(f.x-i.x)+2*d.y*b*(f.y-i.y)+2*(x.x*m.x*g+x.y*m.y*b),2*x.x*g*(f.x-i.x)+2*x.y*b*(f.y-i.y)+m.x*m.x*g+m.y*m.y*b,2*m.x*g*(f.x-i.x)+2*m.y*b*(f.y-i.y),f.x*f.x*g-2*f.y*i.y*b-2*f.x*i.x*g+f.y*f.y*b+i.x*i.x*g+i.y*i.y*b-b*g).getRootsInInterval(0,1);for(const r of w)p.points.push(d.multiply(r*r*r).add(x.multiply(r*r).add(m.multiply(r).add(f))));return p.points.length>0&&(p.status="Intersection"),p}static intersectBezier3Line(t,e,n,s,r,i){let o,c,h,l;const y=r.min(i),p=r.max(i),d=new U("No Intersection");o=t.multiply(-1),c=e.multiply(3),h=n.multiply(-3),l=o.add(c.add(h.add(s)));const x=new a(l.x,l.y);o=t.multiply(3),c=e.multiply(-6),h=n.multiply(3),l=o.add(c.add(h));const m=new a(l.x,l.y);o=t.multiply(-3),c=e.multiply(3),h=o.add(c);const f=new a(h.x,h.y),b=new a(t.x,t.y),g=new a(r.y-i.y,i.x-r.x),w=r.x*i.y-i.x*r.y,v=new u(g.dot(x),g.dot(m),g.dot(f),g.dot(b)+w).getRoots();for(const a of v)if(0<=a&&a<=1){const o=t.lerp(e,a),c=e.lerp(n,a),h=n.lerp(s,a),u=o.lerp(c,a),l=c.lerp(h,a),x=u.lerp(l,a);r.x===i.x?y.y<=x.y&&x.y<=p.y&&(d.status="Intersection",d.appendPoint(x)):r.y===i.y?y.x<=x.x&&x.x<=p.x&&(d.status="Intersection",d.appendPoint(x)):y.x<=x.x&&x.x<=p.x&&y.y<=x.y&&x.y<=p.y&&(d.status="Intersection",d.appendPoint(x))}return d}static intersectBezier3Polygon(t,e,n,s,r){return U.intersectBezier3Polyline(t,e,n,s,F(r))}static intersectBezier3Polyline(t,e,n,s,r){const i=new U("No Intersection"),{length:a}=r;for(let o=0;o<a-1;o++){const a=r[o],c=r[o+1],h=U.intersectBezier3Line(t,e,n,s,a,c);i.appendPoints(h.points)}return i.points.length>0&&(i.status="Intersection"),i}static intersectBezier3Rectangle(t,e,n,s,i,a){const o=i.min(a),c=i.max(a),h=new r(c.x,o.y),u=new r(o.x,c.y),l=U.intersectBezier3Line(t,e,n,s,o,h),y=U.intersectBezier3Line(t,e,n,s,h,c),p=U.intersectBezier3Line(t,e,n,s,c,u),d=U.intersectBezier3Line(t,e,n,s,u,o),x=new U("No Intersection");return x.appendPoints(l.points),x.appendPoints(y.points),x.appendPoints(p.points),x.appendPoints(d.points),x.points.length>0&&(x.status="Intersection"),x}static intersectCircleCircle(t,e,n,s){let i;const a=e+s,o=Math.abs(e-s),c=t.distanceFrom(n);if(c>a)i=new U("Outside");else if(c<o)i=new U("Inside");else{i=new U("Intersection");const a=(e*e-s*s+c*c)/(2*c),o=Math.sqrt(e*e-a*a),h=t.lerp(n,a/c),u=o/c;i.points.push(new r(h.x-u*(n.y-t.y),h.y+u*(n.x-t.x))),i.points.push(new r(h.x+u*(n.y-t.y),h.y-u*(n.x-t.x)))}return i}static intersectCircleEllipse(t,e,n,s,r){return U.intersectEllipseEllipse(t,e,e,n,s,r)}static intersectCircleLine(t,e,n,s){let r;const i=(s.x-n.x)*(s.x-n.x)+(s.y-n.y)*(s.y-n.y),a=2*((s.x-n.x)*(n.x-t.x)+(s.y-n.y)*(n.y-t.y)),o=a*a-4*i*(t.x*t.x+t.y*t.y+n.x*n.x+n.y*n.y-2*(t.x*n.x+t.y*n.y)-e*e);if(o<0)r=new U("Outside");else if(0===o)r=new U("Tangent");else{const t=Math.sqrt(o),e=(-a+t)/(2*i),c=(-a-t)/(2*i);(e<0||e>1)&&(c<0||c>1)?r=new U(e<0&&c<0||e>1&&c>1?"Outside":"Inside"):(r=new U("Intersection"),0<=e&&e<=1&&r.points.push(n.lerp(s,e)),0<=c&&c<=1&&r.points.push(n.lerp(s,c)))}return r}static intersectCirclePolygon(t,e,n){return U.intersectCirclePolyline(t,e,F(n))}static intersectCirclePolyline(t,e,n){const s=new U("No Intersection"),{length:r}=n;let i;for(let a=0;a<r-1;a++){const r=n[a],o=n[a+1];i=U.intersectCircleLine(t,e,r,o),s.appendPoints(i.points)}return s.points.length>0?s.status="Intersection":s.status=i.status,s}static intersectCircleRectangle(t,e,n,s){const i=n.min(s),a=n.max(s),o=new r(a.x,i.y),c=new r(i.x,a.y),h=U.intersectCircleLine(t,e,i,o),u=U.intersectCircleLine(t,e,o,a),l=U.intersectCircleLine(t,e,a,c),y=U.intersectCircleLine(t,e,c,i),p=new U("No Intersection");return p.appendPoints(h.points),p.appendPoints(u.points),p.appendPoints(l.points),p.appendPoints(y.points),p.points.length>0?p.status="Intersection":p.status=h.status,p}static intersectEllipseEllipse(t,e,n,s,i,a){const o=[n*n,0,e*e,-2*n*n*t.x,-2*e*e*t.y,n*n*t.x*t.x+e*e*t.y*t.y-e*e*n*n],c=[a*a,0,i*i,-2*a*a*s.x,-2*i*i*s.y,a*a*s.x*s.x+i*i*s.y*s.y-i*i*a*a],h=function(t,e){const n=t[0]*e[1]-e[0]*t[1],s=t[0]*e[2]-e[0]*t[2],r=t[0]*e[3]-e[0]*t[3],i=t[0]*e[4]-e[0]*t[4],a=t[0]*e[5]-e[0]*t[5],o=t[1]*e[2]-e[1]*t[2],c=t[1]*e[4]-e[1]*t[4],h=t[1]*e[5]-e[1]*t[5],l=t[2]*e[3]-e[2]*t[3],y=t[3]*e[4]-e[3]*t[4],p=t[3]*e[5]-e[3]*t[5],d=h+y,x=c-l;return new u(n*o-s*s,n*x+r*o-2*s*i,n*d+r*x-i*i-2*s*a,n*p+r*d-2*i*a,r*p-a*a)}(o,c).getRoots(),l=.001*(o[0]*o[0]+2*o[1]*o[1]+o[2]*o[2]),y=.001*(c[0]*c[0]+2*c[1]*c[1]+c[2]*c[2]),p=new U("No Intersection");for(let d=0;d<h.length;d++){const t=new u(o[0],o[3]+h[d]*o[1],o[5]+h[d]*(o[4]+h[d]*o[2])).getRoots();for(let e=0;e<t.length;e++){let n=(o[0]*t[e]+o[1]*h[d]+o[3])*t[e]+(o[2]*h[d]+o[4])*h[d]+o[5];Math.abs(n)<l&&(n=(c[0]*t[e]+c[1]*h[d]+c[3])*t[e]+(c[2]*h[d]+c[4])*h[d]+c[5],Math.abs(n)<y&&p.appendPoint(new r(t[e],h[d])))}}return p.points.length>0&&(p.status="Intersection"),p}static intersectEllipseLine(t,e,n,s,r){let i;const o=new a(s.x,s.y),c=a.fromPoints(s,r),h=new a(t.x,t.y),u=o.subtract(h),l=new a(c.x/(e*e),c.y/(n*n)),y=new a(u.x/(e*e),u.y/(n*n)),p=c.dot(l),d=c.dot(y),x=d*d-p*(t=u.dot(y)-1);if(x<0)i=new U("Outside");else if(x>0){const t=Math.sqrt(x),e=(-d-t)/p,n=(-d+t)/p;(e<0||1<e)&&(n<0||1<n)?i=new U(e<0&&n<0||e>1&&n>1?"Outside":"Inside"):(i=new U("Intersection"),0<=e&&e<=1&&i.appendPoint(s.lerp(r,e)),0<=n&&n<=1&&i.appendPoint(s.lerp(r,n)))}else{const t=-d/p;0<=t&&t<=1?(i=new U("Intersection")).appendPoint(s.lerp(r,t)):i=new U("Outside")}return i}static intersectEllipsePolygon(t,e,n,s){return U.intersectEllipsePolyline(t,e,n,F(s))}static intersectEllipsePolyline(t,e,n,s){const r=new U("No Intersection"),{length:i}=s;for(let a=0;a<i-1;a++){const i=s[a],o=s[a+1],c=U.intersectEllipseLine(t,e,n,i,o);r.appendPoints(c.points)}return r.points.length>0&&(r.status="Intersection"),r}static intersectEllipseRectangle(t,e,n,s,i){const a=s.min(i),o=s.max(i),c=new r(o.x,a.y),h=new r(a.x,o.y),u=U.intersectEllipseLine(t,e,n,a,c),l=U.intersectEllipseLine(t,e,n,c,o),y=U.intersectEllipseLine(t,e,n,o,h),p=U.intersectEllipseLine(t,e,n,h,a),d=new U("No Intersection");return d.appendPoints(u.points),d.appendPoints(l.points),d.appendPoints(y.points),d.appendPoints(p.points),d.points.length>0&&(d.status="Intersection"),d}static intersectLineLine(t,e,n,s){let i;const a=(s.x-n.x)*(t.y-n.y)-(s.y-n.y)*(t.x-n.x),o=(e.x-t.x)*(t.y-n.y)-(e.y-t.y)*(t.x-n.x),c=(s.y-n.y)*(e.x-t.x)-(s.x-n.x)*(e.y-t.y);if(0!==c){const n=a/c,s=o/c;0<=n&&n<=1&&0<=s&&s<=1?(i=new U("Intersection")).points.push(new r(t.x+n*(e.x-t.x),t.y+n*(e.y-t.y))):i=new U("No Intersection")}else i=new U(0===a||0===o?"Coincident":"Parallel");return i}static intersectLinePolygon(t,e,n){return U.intersectLinePolyline(t,e,F(n))}static intersectLinePolyline(t,e,n){const s=new U("No Intersection"),{length:r}=n;for(let i=0;i<r-1;i++){const r=n[i],a=n[i+1],o=U.intersectLineLine(t,e,r,a);s.appendPoints(o.points)}return s.points.length>0&&(s.status="Intersection"),s}static intersectLineRectangle(t,e,n,s){const i=n.min(s),a=n.max(s),o=new r(a.x,i.y),c=new r(i.x,a.y),h=U.intersectLineLine(i,o,t,e),u=U.intersectLineLine(o,a,t,e),l=U.intersectLineLine(a,c,t,e),y=U.intersectLineLine(c,i,t,e),p=new U("No Intersection");return p.appendPoints(h.points),p.appendPoints(u.points),p.appendPoints(l.points),p.appendPoints(y.points),p.points.length>0&&(p.status="Intersection"),p}static intersectPolygonPolygon(t,e){return U.intersectPolylinePolyline(F(t),F(e))}static intersectPolygonPolyline(t,e){return U.intersectPolylinePolyline(F(t),e)}static intersectPolygonRectangle(t,e,n){return U.intersectPolylineRectangle(F(t),e,n)}static intersectPolylinePolyline(t,e){const n=new U("No Intersection"),{length:s}=t;for(let r=0;r<s-1;r++){const s=t[r],i=t[r+1],a=U.intersectLinePolyline(s,i,e);n.appendPoints(a.points)}return n.points.length>0&&(n.status="Intersection"),n}static intersectPolylineRectangle(t,e,n){const s=e.min(n),i=e.max(n),a=new r(i.x,s.y),o=new r(s.x,i.y),c=U.intersectLinePolyline(s,a,t),h=U.intersectLinePolyline(a,i,t),u=U.intersectLinePolyline(i,o,t),l=U.intersectLinePolyline(o,s,t),y=new U("No Intersection");return y.appendPoints(c.points),y.appendPoints(h.points),y.appendPoints(u.points),y.appendPoints(l.points),y.points.length>0&&(y.status="Intersection"),y}static intersectRectangleRectangle(t,e,n,s){const i=t.min(e),a=t.max(e),o=new r(a.x,i.y),c=new r(i.x,a.y),h=U.intersectLineRectangle(i,o,n,s),u=U.intersectLineRectangle(o,a,n,s),l=U.intersectLineRectangle(a,c,n,s),y=U.intersectLineRectangle(c,i,n,s),p=new U("No Intersection");return p.appendPoints(h.points),p.appendPoints(u.points),p.appendPoints(l.points),p.appendPoints(y.points),p.points.length>0&&(p.status="Intersection"),p}static intersectRayRay(t,e,n,s){let i;const a=(s.x-n.x)*(t.y-n.y)-(s.y-n.y)*(t.x-n.x),o=(e.x-t.x)*(t.y-n.y)-(e.y-t.y)*(t.x-n.x),c=(s.y-n.y)*(e.x-t.x)-(s.x-n.x)*(e.y-t.y);if(0!==c){const n=a/c;(i=new U("Intersection")).points.push(new r(t.x+n*(e.x-t.x),t.y+n*(e.y-t.y)))}else i=new U(0===a||0===o?"Coincident":"Parallel");return i}appendPoint(t){this.points.push(t)}appendPoints(t){this.points=this.points.concat(t)}}var Q=U;const W={pointInCircle:function(t,e,n){return a.fromPoints(e,t).length()<=n},pointInEllipse:function(t,e,n,s){const r=t.subtract(e);return r.x*r.x/(n*n)+r.y*r.y/(s*s)<=1},pointInPolyline:function(t,e){const{length:n}=e;let s,r=0,i=e[0];for(let a=1;a<=n;a++){const o=e[a%n],c=Math.min(i.y,o.y),h=Math.max(i.y,o.y),u=Math.max(i.x,o.x);i.y!==o.y&&c<t.y&&t.y<=h&&t.x<=u&&(s=(t.y-i.y)*(o.x-i.x)/(o.y-i.y)+i.x,(i.x===o.x||t.x<=s)&&r++),i=o}return r%2===1}};W.pointInPolygon=W.pointInPolyline,W.pointInRectangle=function(t,e,n){return e.x<=t.x&&t.x<n.x&&e.y<=t.y&&t.y<n.y};n.d(e,"a",function(){return Z}),n.d(e,"d",function(){return G}),n.d(e,"e",function(){return V}),n.d(e,"b",function(){return H}),n.d(e,"c",function(){return J});var Z=function(t,e){return Q.intersect(t,e).points},G=function(t){return Y.quadraticBezier(t.src,t.c1,t.dst)},V=function(t){return Y.rectangle({top:t.x,left:t.y,width:t.width,height:t.height})},H=function(t){return Y.ellipse(t.center.x,t.center.y,t.rx,t.ry)},J=function(t){return Y.line(t.src,t.dst)}},g2Zv:function(t,e,n){"use strict";var s=n("Sxkx");e.a=function(t){return t&&Object(s.c)(t.x)&&Object(s.c)(t.y)}},hCWT:function(t,e,n){"use strict";var s=n("1Ldg");e.a=s.a},hsuq:function(t,e,n){"use strict";var s=n("z3IF"),r=n("hDBU"),i=n("2Fjn"),a=n("mXGw"),o=n.n(a),c=n("PDtE"),h=n("SQNZ"),u=n("/F3D"),l=o.a.createElement,y=6,p=6,d=function(t){var e=t.id,n=t.width,o=void 0===n?y:n,d=t.height,x=void 0===d?p:d,m=t.stroke,f=void 0===m?"none":m,b=t.strokeWidth,g=t.rtl,w=t.className,v=Object(i.a)(t,["id","width","height","stroke","strokeWidth","rtl","className"]),E=Object(a.useMemo)(function(){var t=Object(h.a)(o,x,f,b),e=Object(r.a)(t,2);return function(t,e,n){var s=e/2;return[{x:0,y:-s},{x:n?-t:t,y:0},{x:0,y:s}]}(e[0],e[1],g).map(u.a)},[x,g,f,b,o]);return l("polygon",Object(s.a)({id:e,points:E,className:Object(c.a)("regraph-arrowhead","regraph-arrowhead-triangle",w),stroke:f},v))};d.getMarkerProps=function(t){var e=t.width,n=void 0===e?y:e,s=t.height,r=void 0===s?p:s;return{width:n,height:r,viewBox:{x:t.rtl?-n:0,y:-r/2,width:n,height:r},anchor:{x:0,y:0},trim:n}},e.a=d},lpvu:function(t,e,n){"use strict";var s=n("2Fjn"),r=n("mXGw"),i=n.n(r),a=n("obYp"),o=n("Rbzu"),c=function(t){return"[object Object]"===Object.prototype.toString.call(t)},h=function(t){return function(e){return Object(o.a)({},e,t(e))}},u=function(t){var e=function(t){var e=t.src,n=t.dst;return{src:c(e)?e:{id:e},dst:c(n)?n:{id:n}}}(t),n=e.src,s=e.dst;return n!==t.src||s!==t.dst?Object(o.a)({},t,{src:n,dst:s}):t},l=h(function(t){var e=t.connections;return{connections:Object(r.useMemo)(function(){return e.map(u)},[e])}}),y=n("2xrT"),p=n.n(y),d=p.a,x=function(t){return t.replace(/\s/g,"")},m=function(t){return t.id||"(".concat(t.x,",").concat(t.y,")")},f=function(t,e){var n=x(function(t){var e=t.src,n=t.dst;return"".concat(m(e),"->").concat(m(n))}(t)),s=Object(o.a)({},t,{id:n});return(e[n]=e[n]||[]).push(s),s},b=function(t){return t.length>1},g=h(function(t){var e=t.connections;return{connections:Object(r.useMemo)(function(){var t={},n=e.map(function(t){return function(e){return e.id?e:f(e,t)}}(t));return function(t){d(t).filter(b).forEach(function(t){t.forEach(function(t,e){t.id="".concat(e+1,".").concat(t.id)})})}(t),n},[e])}}),w=n("pL2a"),v=n.n(w),E=n("1qCV"),P=n.n(E),k=n("K4BZ"),M=(P.a,p.a,v.a,function(){for(var t=arguments.length,e=new Array(t),n=0;n<t;n++)e[n]=arguments[n];return function(t){return e.reduce(function(t,e){return e(t)},t)}}),O=function(t){return t.id||"(".concat(t.x,",").concat(t.y,")")},j=function(t){return t.reduce(function(t,e){var n,s=[(n=e).src,n.dst].map(O).sort().join("<->");return(t[s]=t[s]||[]).push(e),t},{})},A=function(t){return t.length>1},T=function(t){return p()(t).filter(A)},R=function(t){return function(e){return e.reduce(function(e,n){var s=function(t,e){var n=(t.length-1)*e;return n-n/2}(n,t),r=O(n[0].src),i=function(t){return O(t.src)!==r},a=function(e){return s-t*e};return n.forEach(function(t,n){e[t.id]=Object(o.a)({},t,{bend:i(t)?-a(n):a(n)})}),e},{})}},N=function(t){return function(e){return t.map(function(t){return e[t.id]||t})}},I=function(t,e){var n=function(t){var e=t.box,n=t.x,s=t.y,r=t.width,i=t.height;return e||n&&s&&{x:n,y:s,width:r,height:i}}(e);return n&&(t[e.id]=n),t},_=h(function(t){var e=t.nodes,n=t.boxes,s=Object(r.useMemo)(function(){return function(t){return t.reduce(I,{})}(e)},[e]);return{boxes:Object(r.useMemo)(function(){return Object(o.a)({},s,n)},[s,n])}}),X=n("FBSb"),$=n("s20r"),C=n.n($);var Y=n("8ET1"),L=n.n(Y),S=n("7X5e"),B=n.n(S);function D(t){return function(t){if(C()(t)){for(var e=0,n=new Array(t.length);e<t.length;e++)n[e]=t[e];return n}}(t)||function(t){if(B()(Object(t))||"[object Arguments]"===Object.prototype.toString.call(t))return L()(t)}(t)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance")}()}var z=function(t){return t.y},q=function(t){return t.x+t.width},F=function(t){return t.y+t.height},U=function(t){return t.x},Q=function(t){return function(e){return t.apply(void 0,D(e))}},W=Q(Math.min),Z=Q(Math.max),G=p.a,V={x:0,y:0,width:0,height:0},H=function(t){return Object(k.a)(t)?t:Object(o.a)({},V,t)},J=function(t){var e=G(t).map(H);return Object(X.a)(e)?{width:0,height:0}:function(t){return e=W(t.map(z)),n=Z(t.map(q)),s=Z(t.map(F)),{x:r=W(t.map(U)),y:e,width:n-r,height:s-e};var e,n,s,r}(e)},K=function(t,e){return Object(r.useMemo)(function(){var n=[q(t),F(t)],s=n[0],r=n[1],i=function(t,e){return"function"===typeof e?e(t):c(e)?e:{right:t.x,bottom:t.y}}(t,e);return{width:s+i.right,height:r+i.bottom}},[t,e])},tt=n("1VIh"),et=n("CcWs"),nt=i.a.createElement;e.a=function(t){var e,n=t.viewportPadding,i=t.layout,o=void 0===i?Object(tt.a)(et.a):i,c=Object(s.a)(t,["viewportPadding","layout"]),u=M(l,g,function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:12;return h(function(e){var n=e.connections;return{connections:M(j,T,R(t),N(n))(n)}})}(),_,function(t){return function(e){return Object(r.useMemo)(function(){return t(e)},t.deps(e))}}(o),(e=n,h(function(t){var n=t.boxes,s=Object(r.useMemo)(function(){return J(n)},[n]);return K(s,e)})))(c);return nt(a.a,u)}},md7T:function(t,e,n){n("6JBb"),t.exports=n("TaGV").Object.values},pL2a:function(t,e,n){t.exports=n("AXMb")},rxwB:function(t,e,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/examples/arrowheads",function(){return n("s9B1")}])},s9B1:function(t,e,n){"use strict";n.r(e);var s=n("z3IF"),r=n("2Fjn"),i=n("mXGw"),a=n.n(i),o=n("SAVP"),c=n("qImK"),h=n("lpvu"),u=n("8foj"),l=n("PDtE"),y=a.a.createElement,p=Math.ceil,d=6,x=6,m=function(t){var e=t.id,n=t.width,a=void 0===n?d:n,o=t.height,c=void 0===o?x:o,h=t.rtl,u=t.className,m=Object(r.a)(t,["id","width","height","rtl","className"]),f=Object(i.useMemo)(function(){return function(t,e,n){var s=n?t:-t,r=p(e/2);return{x1:s,y1:-r,x2:s,y2:r}}(a,c,h)},[c,a,h]);return y("line",Object(s.a)({id:e},f,{className:Object(l.a)("regraph-arrowhead","regraph-arrowhead-perp",u),strokeWidth:1,fill:"none"},m))};m.getMarkerProps=function(t){var e=t.width,n=void 0===e?d:e,s=t.height,r=void 0===s?x:s;return{width:n,height:r,viewBox:{x:t.rtl?0:-n,y:-r/2,width:n,height:r},anchor:{x:0,y:0},trim:0}};var f=m,b=n("hsuq"),g=a.a.createElement,w=function(t){var e=t.box;return g("rect",e)},v=function(t,e){return{id:t,type:w,box:{x:50+100*e,y:40,width:20,height:20}}},E=g(f,null),P=g(b.a,null),k=n("Rbzu"),M=n("hDBU"),O=n("SQNZ"),j=n("/F3D"),A=a.a.createElement,T=6,R=6,N="inherent",I=function(t){var e=t.id,n=t.width,a=void 0===n?T:n,o=t.height,c=void 0===o?R:o,h=t.stroke,u=void 0===h?N:h,y=t.strokeWidth,p=t.rtl,d=t.className,x=Object(r.a)(t,["id","width","height","stroke","strokeWidth","rtl","className"]),m=Object(i.useMemo)(function(){var t=Object(O.a)(a,c,u,y),e=Object(M.a)(t,2);return function(t,e,n){var s=n?t:-t,r=e/2;return[{x:s,y:-r},{x:0,y:0},{x:s,y:r}]}(e[0],e[1],p).map(j.a)},[c,p,u,y,a]);return A("polyline",Object(s.a)({id:e,points:m,className:Object(l.a)("regraph-arrowhead","regraph-arrowhead-chevy",d),stroke:u,strokeLinejoin:"bevel",fill:"none"},x))};I.getMarkerProps=function(t){var e=t.width,n=void 0===e?T:e,s=t.height,r=void 0===s?R:s;return{width:n,height:r,viewBox:{x:t.rtl?0:-n,y:-r/2,width:n,height:r},anchor:{x:0,y:0},trim:0}};var _=I,X=a.a.createElement,$=6,C=12,Y="inherent",L=function(t){var e=t.id,n=t.width,a=void 0===n?$:n,o=t.height,c=void 0===o?C:o,h=t.stroke,u=void 0===h?Y:h,y=t.strokeWidth,p=t.rtl,d=t.className,x=Object(r.a)(t,["id","width","height","stroke","strokeWidth","rtl","className"]),m=Object(i.useMemo)(function(){var t=Object(O.a)(a,c,u,y),e=Object(M.a)(t,2);return function(t,e,n){var s=n?-1:1,r=e/2,i=t/2,a=s*t,o=a-s*i,c={x:a,y:-r},h={x:o,y:-r},u={x:o,y:-r+i},l={x:o,y:-i},y={x:o,y:0},p={x:o,y:i},d={x:o,y:r-i},x={x:o,y:r},m={x:a,y:r};return"\n    M ".concat(Object(j.a)(c),"\n    Q ").concat(Object(j.a)(h)," ").concat(Object(j.a)(u),"\n    L ").concat(Object(j.a)(l),"\n    Q ").concat(Object(j.a)(y)," ").concat(Object(j.a)({x:0,y:0}),"\n    Q ").concat(Object(j.a)(y)," ").concat(Object(j.a)(p),"\n    L ").concat(Object(j.a)(d),"\n    Q ").concat(Object(j.a)(x)," ").concat(Object(j.a)(m),"\n  ")}(e[0],e[1],p)},[c,p,u,y,a]);return X("path",Object(s.a)({id:e,d:m,className:Object(l.a)("regraph-arrowhead","regraph-arrowhead-curly",d),stroke:u,fill:"none"},x))};L.getMarkerProps=function(t){var e=t.width,n=void 0===e?$:e,s=t.height,r=void 0===s?C:s;return{width:n,height:r,viewBox:{x:t.rtl?0:-n,y:-r/2,width:n,height:r},anchor:{x:0,y:0},trim:n}};var S=L,B=a.a.createElement,D=6,z=6,q=.25,F=function(t){var e=t.id,n=t.width,a=void 0===n?D:n,o=t.height,c=void 0===o?z:o,h=t.inset,u=void 0===h?q:h,y=t.stroke,p=t.strokeWidth,d=t.rtl,x=t.className,m=Object(r.a)(t,["id","width","height","inset","stroke","strokeWidth","rtl","className"]),f=Object(i.useMemo)(function(){var t=Object(O.a)(a,c,y,p),e=Object(M.a)(t,2);return function(t,e,n,s){var r=s?-1:1,i=e/2,a=-n*t;return[{x:0,y:0},{x:r*a,y:-i},{x:r*((1-n)*t),y:0},{x:r*a,y:i}]}(e[0],e[1],u,d).map(j.a)},[c,u,d,y,p,a]);return B("polygon",Object(s.a)({id:e,points:f,className:Object(l.a)("regraph-arrowhead","regraph-arrowhead-barbed",x),stroke:y},m))};F.getMarkerProps=function(t){var e=t.width,n=void 0===e?D:e,s=t.height,r=void 0===s?z:s,i=t.inset,a=void 0===i?q:i;return{width:n,height:r,viewBox:{x:t.rtl?-(1-a)*n:-a*n,y:-r/2,width:n,height:r},anchor:{x:0,y:0},trim:(1-a)*n}};var U=F,Q=a.a.createElement,W=10,Z=5,G=function(t){var e=t.id,n=t.width,a=void 0===n?W:n,o=t.height,c=void 0===o?Z:o,h=t.stroke,u=t.strokeWidth,y=t.rtl,p=t.className,d=Object(r.a)(t,["id","width","height","stroke","strokeWidth","rtl","className"]),x=Object(i.useMemo)(function(){var t=Object(O.a)(a,c,h,u),e=Object(M.a)(t,2);return function(t,e,n){var s=n?-1:1,r=e/2,i=t/2;return[{x:0,y:0},{x:s*i,y:-r},{x:s*t,y:0},{x:s*i,y:r}].map(function(t){return t.x-=s,t})}(e[0],e[1],y).map(j.a)},[c,y,h,u,a]);return Q("polygon",Object(s.a)({id:e,points:x,className:Object(l.a)("regraph-arrowhead","regraph-arrowhead-diamond",p),stroke:h},d))};G.getMarkerProps=function(t){var e=t.width,n=void 0===e?W:e,s=t.height,r=void 0===s?Z:s;return{width:n,height:r,viewBox:{x:t.rtl?-n:0,y:-r/2,width:n,height:r},anchor:{x:0,y:0},trim:n-1}};var V=G,H=a.a.createElement,J=6,K=6,tt=function(t){var e=t.id,n=t.width,a=void 0===n?J:n,o=t.height,c=void 0===o?K:o,h=t.stroke,u=t.strokeWidth,y=t.rtl,p=t.className,d=Object(r.a)(t,["id","width","height","stroke","strokeWidth","rtl","className"]),x=Object(i.useMemo)(function(){return function(t,e,n,s){var r=s?-1:1;return{cx:t/2*r-r,cy:0,rx:(t-n)/2,ry:(e-n)/2}}(a,c,Object(O.b)(h,u),y)},[c,y,h,u,a]);return H("ellipse",Object(s.a)({id:e},x,{className:Object(l.a)("regraph-arrowhead","regraph-arrowhead-ellipse",p),stroke:h},d))};tt.getMarkerProps=function(t){var e=t.width,n=void 0===e?J:e,s=t.height,r=void 0===s?K:s;return{width:n,height:r,viewBox:{x:t.rtl?-n:0,y:-r/2,width:n,height:r},anchor:{x:0,y:0},trim:n-1}};var et=tt,nt=n("1Ldg"),st=a.a.createElement,rt=function(t){var e=t.id,n=t.box,s=t.title,r=Object(nt.a)(n),i=r.x,a=r.y;return st("g",{key:e},st("rect",n),st("text",{x:i,y:a,textAnchor:"middle",dominantBaseline:"central",fill:"#604A0E"},s))},it=a.a.createElement,at={stroke:"none",fill:"inherent"},ot={stroke:"inherent",fill:"none"},ct=[{src:{id:"Perp",marker:it(f,null)},dst:{id:"Chevy",marker:it(_,null)}},{src:{id:"Curly",marker:it(S,{height:15})},dst:{id:"Barbed",marker:it(U,at)}},{src:{id:"Triangle (Full)",marker:it(b.a,at)},dst:{id:"Triangle (Empty)",marker:it(b.a,ot)}},{src:{id:"Diamond (Full)",marker:it(V,at)},dst:{id:"Diamond (Empty)",marker:it(V,ot)}},{src:{id:"Ellipse (Full)",marker:it(et,at)},dst:{id:"Ellipse (Empty)",marker:it(et,ot)}}].map(function(t){return Object(k.a)({},t,{type:u.a,strokeWidth:2})}),ht=function(t){return t.split(" ")[0]},ut=ct.reduce(function(t,e,n){var s=e.src,r=e.dst,i={y:50*n+50,width:150,height:30};return t.push({id:s.id,type:rt,title:ht(s.id),box:Object(k.a)({x:50},i)},{id:r.id,type:rt,title:ht(r.id),box:Object(k.a)({x:300},i)}),t},[]),lt=it(h.a,{nodes:ut,connections:ct});n.d(e,"default",function(){return gt});a.a.createElement;var yt={},pt="wrapper",dt=Object(o.a)("h1",null,"Arrowheads"),xt=Object(o.a)("p",null,"Basic example:"),mt=Object(o.a)(c.a,{code:"import React from 'react';\nimport { Graph } from '@regraph/graph';\nimport { Line } from '@regraph/connections';\nimport { Triangle, Perp } from '@regraph/arrowheads';\n\nconst Rect = ({ box }) => <rect {...box} />;\n\nconst toNode = (id, index) => ({\n  id,\n  type: Rect,\n  box: { x: 50 + index * 100, y: 40, width: 20, height: 20 },\n});\n\nexport default () => (\n  <Graph\n    nodes={['left', 'centre', 'right'].map(toNode)}\n    connections={[\n      { src: 'centre', dst: 'left' },\n      { src: 'centre', dst: 'right' },\n    ]}\n    connection={{\n      type: Line,\n      strokeWidth: 2,\n      src: { marker: <Perp /> },\n      dst: { marker: <Triangle /> },\n    }}\n  />\n);\n",output:Object(o.a)(function(){return g(h.a,{nodes:["left","centre","right"].map(v),connections:[{src:"centre",dst:"left"},{src:"centre",dst:"right"}],connection:{type:u.a,strokeWidth:2,src:{marker:E},dst:{marker:P}}})},{mdxType:"Graph"}),path:"examples/arrowheads/index.jsx",mdxType:"Example"}),ft=Object(o.a)("p",null,"Some more arrowheads:"),bt=Object(o.a)(c.a,{code:"import React from 'react';\nimport { Graph } from '@regraph/graph';\nimport { Line } from '@regraph/connections';\nimport {\n  Triangle,\n  Perp,\n  Chevy,\n  Ellipse,\n  Diamond,\n  Barbed,\n  Curly,\n} from '@regraph/arrowheads';\nimport TextBox from './TextBox';\n\nconst full = { stroke: 'none', fill: 'inherent' };\nconst empty = { stroke: 'inherent', fill: 'none' };\n\nconst applyConnectionDefaults = connection => ({\n  ...connection,\n  type: Line,\n  strokeWidth: 2,\n});\nconst connections = [\n  {\n    src: { id: 'Perp', marker: <Perp /> },\n    dst: { id: 'Chevy', marker: <Chevy /> },\n  },\n  {\n    src: { id: 'Curly', marker: <Curly height={15} /> },\n    dst: { id: 'Barbed', marker: <Barbed {...full} /> },\n  },\n  {\n    src: { id: 'Triangle (Full)', marker: <Triangle {...full} /> },\n    dst: { id: 'Triangle (Empty)', marker: <Triangle {...empty} /> },\n  },\n  {\n    src: { id: 'Diamond (Full)', marker: <Diamond {...full} /> },\n    dst: { id: 'Diamond (Empty)', marker: <Diamond {...empty} /> },\n  },\n  {\n    src: { id: 'Ellipse (Full)', marker: <Ellipse {...full} /> },\n    dst: { id: 'Ellipse (Empty)', marker: <Ellipse {...empty} /> },\n  },\n].map(applyConnectionDefaults);\n\nconst firstWord = str => str.split(' ')[0];\n\nconst nodesReducer = (nodes, { src, dst }, index) => {\n  const box = { y: index * 50 + 50, width: 150, height: 30 };\n  nodes.push(\n    {\n      id: src.id,\n      type: TextBox,\n      title: firstWord(src.id),\n      box: { x: 50, ...box },\n    },\n    {\n      id: dst.id,\n      type: TextBox,\n      title: firstWord(dst.id),\n      box: { x: 300, ...box },\n    }\n  );\n  return nodes;\n};\n\nconst nodes = connections.reduce(nodesReducer, []);\n\nexport default () => <Graph nodes={nodes} connections={connections} />;\n",output:Object(o.a)(function(){return lt},{mdxType:"GraphAll"}),path:"examples/arrowheads/all.jsx",mdxType:"Example"});function gt(t){var e=t.components,n=Object(r.a)(t,["components"]);return Object(o.a)(pt,Object(s.a)({},yt,n,{components:e,mdxType:"MDXLayout"}),dt,xt,mt,ft,bt)}gt.isMDXComponent=!0}},[["rxwB",1,0]]]);