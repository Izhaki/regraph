(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{"1Ldg":function(t,e,n){"use strict";e.a=function(t){return{x:t.x+t.width/2,y:t.y+t.height/2}}},"1VIh":function(t,e,n){"use strict";var s=n("Rbzu"),r=n("hCWT"),i=n("K4BZ"),a=n("FBSb"),o=n("g2Zv"),c=function(t,e){return t.connections.map(function(n){if(function(t){var e=t.src,n=t.dst;return!Object(o.a)(e)||!Object(o.a)(n)}(n)){var r=e(t,n);if(!Object(a.a)(r))return Object(s.a)({},n,r)}return n})};e.a=function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:r.a;return function(e,n){var r=e.boxes,a=n.src,o=n.dst,c={},h=r[a.id],u=r[o.id];return Object(i.a)(h)&&(c.src=Object(s.a)({},a,t(h))),Object(i.a)(u)&&(c.dst=Object(s.a)({},o,t(u))),c}}(),e=function(e){return Object(s.a)({},e,{connections:c(e,t)})};return e.deps=function(t){return[t.boxes,t.connections]},e}},"2xrT":function(t,e,n){t.exports=n("md7T")},"31MD":function(t,e,n){var s=n("/6KZ"),r=n("SvME")(!0);s(s.S,"Object",{entries:function(t){return r(t)}})},"5dM6":function(t,e,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/examples/basic-graph",function(){return n("oGUj")}])},"6JBb":function(t,e,n){var s=n("/6KZ"),r=n("SvME")(!1);s(s.S,"Object",{values:function(t){return r(t)}})},AXMb:function(t,e,n){n("31MD"),t.exports=n("TaGV").Object.entries},CcWs:function(t,e,n){"use strict";var s=n("Rbzu"),r=n("hCWT"),i=n("K4BZ"),a=n("V+3i"),o=function(t,e){return function(t,e){return Object(a.a)(Object(a.c)(t),Object(a.e)(e))}(t,e)[0]};e.a=function(t,e){var n=t.boxes,a=e.src,c=e.dst,h={},u=n[a.id],l=n[c.id];if(!Object(i.a)(u)||!Object(i.a)(l))return h;var y={src:Object(i.a)(u)?Object(r.a)(u):a,dst:Object(i.a)(l)?Object(r.a)(l):c};return h.src=Object(s.a)({},a,o(y,u)),h.dst=Object(s.a)({},c,o(y,l)),h}},FBSb:function(t,e,n){"use strict";var s=n("1qCV"),r=n.n(s).a;e.a=function(t){return void 0===t||null===t||(t.length?0===t.length:"object"===typeof t&&0===r(t).length)}},K4BZ:function(t,e,n){"use strict";var s=n("Sxkx");e.a=function(t){return t&&Object(s.c)(t.x)&&Object(s.c)(t.y)&&Object(s.c)(t.width)&&Object(s.c)(t.height)}},SvME:function(t,e,n){var s=n("lBnu"),r=n("/Lgp"),i=n("T/1i"),a=n("kBaS").f;t.exports=function(t){return function(e){for(var n,o=i(e),c=r(o),h=c.length,u=0,l=[];h>u;)n=c[u++],s&&!a.call(o,n)||l.push(t?[n,o[n]]:o[n]);return l}}},"V+3i":function(t,e,n){"use strict";var s={};n.r(s),n.d(s,"typeName",function(){return y}),n.d(s,"length",function(){return p}),n.d(s,"zip",function(){return x}),n.d(s,"partition",function(){return d}),n.d(s,"reverse",function(){return m}),n.d(s,"sort",function(){return f}),n.d(s,"join",function(){return b}),n.d(s,"keys",function(){return w}),n.d(s,"values",function(){return v}),n.d(s,"pairs",function(){return P}),n.d(s,"fromPairs",function(){return E}),n.d(s,"merge",function(){return M});var r=class{constructor(t=0,e=0){this.x=t,this.y=e}clone(){return new this.constructor(this.x,this.y)}add(t){return new this.constructor(this.x+t.x,this.y+t.y)}subtract(t){return new this.constructor(this.x-t.x,this.y-t.y)}multiply(t){return new this.constructor(this.x*t,this.y*t)}divide(t){return new this.constructor(this.x/t,this.y/t)}equals(t){return this.x===t.x&&this.y===t.y}precisionEquals(t,e){return Math.abs(this.x-t.x)<e&&Math.abs(this.y-t.y)<e}lerp(t,e){const n=1-e;return new this.constructor(this.x*n+t.x*e,this.y*n+t.y*e)}distanceFrom(t){const e=this.x-t.x,n=this.y-t.y;return Math.sqrt(e*e+n*n)}min(t){return new this.constructor(Math.min(this.x,t.x),Math.min(this.y,t.y))}max(t){return new this.constructor(Math.max(this.x,t.x),Math.max(this.y,t.y))}transform(t){return new this.constructor(t.a*this.x+t.c*this.y+t.e,t.b*this.x+t.d*this.y+t.f)}toString(){return`point(${this.x},${this.y})`}};class i{constructor(t=0,e=0){this.x=t,this.y=e}static fromPoints(t,e){return new i(e.x-t.x,e.y-t.y)}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}magnitude(){return this.x*this.x+this.y*this.y}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}determinant(t){return this.x*t.y-this.y*t.x}unit(){return this.divide(this.length())}add(t){return new this.constructor(this.x+t.x,this.y+t.y)}subtract(t){return new this.constructor(this.x-t.x,this.y-t.y)}multiply(t){return new this.constructor(this.x*t,this.y*t)}divide(t){return new this.constructor(this.x/t,this.y/t)}angleBetween(t){let e=this.dot(t)/(this.length()*t.length());e=Math.max(-1,Math.min(e,1));const n=Math.acos(e);return this.cross(t)<0?-n:n}perp(){return new this.constructor(-this.y,this.x)}perpendicular(t){return this.subtract(this.project(t))}project(t){const e=this.dot(t)/t.dot(t);return t.multiply(e)}transform(t){return new this.constructor(t.a*this.x+t.c*this.y,t.b*this.x+t.d*this.y)}equals(t){return this.x===t.x&&this.y===t.y}precisionEquals(t,e){return Math.abs(this.x-t.x)<e&&Math.abs(this.y-t.y)<e}toString(){return`vector(${this.x},${this.y})`}}var a=i;class o{constructor(t=1,e=0,n=0,s=1,r=0,i=0){this.a=t,this.b=e,this.c=n,this.d=s,this.e=r,this.f=i}static translation(t,e){return new o(1,0,0,1,t,e)}static scaling(t){return new o(t,0,0,t,0,0)}static scalingAt(t,e){return new o(t,0,0,t,e.x-e.x*t,e.y-e.y*t)}static nonUniformScaling(t,e){return new o(t,0,0,e,0,0)}static nonUniformScalingAt(t,e,n){return new o(t,0,0,e,n.x-n.x*t,n.y-n.y*e)}static rotation(t){const e=Math.cos(t),n=Math.sin(t);return new o(e,n,-n,e,0,0)}static rotationAt(t,e){const n=Math.cos(t),s=Math.sin(t);return new o(n,s,-s,n,e.x-e.x*n+e.y*s,e.y-e.y*n-e.x*s)}static rotationFromVector(t){const e=t.unit(),n=e.x,s=e.y;return new o(n,s,-s,n,0,0)}static xFlip(){return new o(-1,0,0,1,0,0)}static yFlip(){return new o(1,0,0,-1,0,0)}static xSkew(t){const e=Math.tan(t);return new o(1,0,e,1,0,0)}static ySkew(t){const e=Math.tan(t);return new o(1,e,0,1,0,0)}multiply(t){return this.isIdentity()?t:t.isIdentity()?this:new this.constructor(this.a*t.a+this.c*t.b,this.b*t.a+this.d*t.b,this.a*t.c+this.c*t.d,this.b*t.c+this.d*t.d,this.a*t.e+this.c*t.f+this.e,this.b*t.e+this.d*t.f+this.f)}inverse(){if(this.isIdentity())return this;const t=this.a*this.d-this.b*this.c;if(0===t)throw new Error("Matrix is not invertible");const e=1/t,n=this.f*this.c-this.e*this.d,s=this.e*this.b-this.f*this.a;return new this.constructor(this.d*e,-this.b*e,-this.c*e,this.a*e,n*e,s*e)}translate(t,e){return new this.constructor(this.a,this.b,this.c,this.d,this.a*t+this.c*e+this.e,this.b*t+this.d*e+this.f)}scale(t){return new this.constructor(this.a*t,this.b*t,this.c*t,this.d*t,this.e,this.f)}scaleAt(t,e){const n=e.x-t*e.x,s=e.y-t*e.y;return new this.constructor(this.a*t,this.b*t,this.c*t,this.d*t,this.a*n+this.c*s+this.e,this.b*n+this.d*s+this.f)}scaleNonUniform(t,e){return new this.constructor(this.a*t,this.b*t,this.c*e,this.d*e,this.e,this.f)}scaleNonUniformAt(t,e,n){const s=n.x-t*n.x,r=n.y-e*n.y;return new this.constructor(this.a*t,this.b*t,this.c*e,this.d*e,this.a*s+this.c*r+this.e,this.b*s+this.d*r+this.f)}rotate(t){const e=Math.cos(t),n=Math.sin(t);return new this.constructor(this.a*e+this.c*n,this.b*e+this.d*n,this.a*-n+this.c*e,this.b*-n+this.d*e,this.e,this.f)}rotateAt(t,e){const n=Math.cos(t),s=Math.sin(t),r=e.x,i=e.y,a=this.a*n+this.c*s,o=this.b*n+this.d*s,c=this.c*n-this.a*s,h=this.d*n-this.b*s;return new this.constructor(a,o,c,h,(this.a-a)*r+(this.c-c)*i+this.e,(this.b-o)*r+(this.d-h)*i+this.f)}rotateFromVector(t){const e=t.unit(),n=e.x,s=e.y;return new this.constructor(this.a*n+this.c*s,this.b*n+this.d*s,this.a*-s+this.c*n,this.b*-s+this.d*n,this.e,this.f)}flipX(){return new this.constructor(-this.a,-this.b,this.c,this.d,this.e,this.f)}flipY(){return new this.constructor(this.a,this.b,-this.c,-this.d,this.e,this.f)}skewX(t){const e=Math.tan(t);return new this.constructor(this.a,this.b,this.c+this.a*e,this.d+this.b*e,this.e,this.f)}skewY(t){const e=Math.tan(t);return new this.constructor(this.a+this.c*e,this.b+this.d*e,this.c,this.d,this.e,this.f)}isIdentity(){return 1===this.a&&0===this.b&&0===this.c&&1===this.d&&0===this.e&&0===this.f}isInvertible(){return this.a*this.d-this.b*this.c!==0}getScale(){return{scaleX:Math.sqrt(this.a*this.a+this.c*this.c),scaleY:Math.sqrt(this.b*this.b+this.d*this.d)}}getDecomposition(){const t=.5*(this.a+this.d),e=.5*(this.a-this.d),n=.5*(this.b+this.c),s=.5*(this.b-this.c),r=Math.sqrt(t*t+s*s),i=Math.sqrt(e*e+n*n),a=r+i,o=r-i,c=Math.atan2(n,e),h=Math.atan2(s,t),u=.5*(h-c),l=.5*(h+c);return{translation:this.constructor.translation(this.e,this.f),rotation:this.constructor.rotation(l),scale:this.constructor.nonUniformScaling(a,o),rotation0:this.constructor.rotation(u)}}equals(t){return this.a===t.a&&this.b===t.b&&this.c===t.c&&this.d===t.d&&this.e===t.e&&this.f===t.f}precisionEquals(t,e){return Math.abs(this.a-t.a)<e&&Math.abs(this.b-t.b)<e&&Math.abs(this.c-t.c)<e&&Math.abs(this.d-t.d)<e&&Math.abs(this.e-t.e)<e&&Math.abs(this.f-t.f)<e}toString(){return`matrix(${this.a},${this.b},${this.c},${this.d},${this.e},${this.f})`}}o.IDENTITY=new o,o.IDENTITY.isIdentity=()=>!0;function c(t){return"number"===typeof t?t?t<0?-1:1:t===t?t:NaN:NaN}class h{constructor(...t){this.coefs=[];for(let e=t.length-1;e>=0;e--)this.coefs.push(t[e]);this._variable="t",this._s=0}static interpolate(t,e,n,s,r){if(t.constructor!==Array||e.constructor!==Array)throw new TypeError("xs and ys must be arrays");if(isNaN(n)||isNaN(s)||isNaN(r))throw new TypeError("n, offset, and x must be numbers");let i,a,o=0;const c=new Array(n),h=new Array(n);let u=0,l=Math.abs(r-t[s]);for(i=0;i<n;i++){const n=Math.abs(r-t[s+i]);n<l&&(u=i,l=n),c[i]=h[i]=e[s+i]}a=e[s+u],u--;for(let y=1;y<n;y++){for(i=0;i<n-y;i++){const e=t[s+i]-r,n=t[s+i+y]-r,a=c[i+1]-h[i];let o=e-n;if(0===o)throw new RangeError("Unable to interpolate polynomial. Two numbers in n were identical (to within roundoff)");o=a/o,h[i]=n*o,c[i]=e*o}a+=o=2*(u+1)<n-y?c[u+1]:h[u--]}return{y:a,dy:o}}static newtonSecantBisection(t,e,n,s,r,i){let a,o,h,u,l,y,p,x=0,d=0;a=t;const m=Math.pow(10,-14),f="number"===typeof r&&"number"===typeof i;if(f){if(r>i)throw new RangeError("Min must be greater than max");if(y=e(r),p=e(i),c(y)===c(p))throw new RangeError("Y values of bounds must be of opposite sign")}const b=function(){return Math.abs(h)<=m*Math.abs(a)||d===a-h-a};for(let g=0;g<s;g++){if(0===(o=n(a))){if(0===x)throw new RangeError("df(x) is zero");o=x}if(x=o,l=e(a),u=a-(h=l/o),b())break;if(f){if(c(l)===c(p))i=a,p=l;else{if(c(l)!==c(y)){a=u;break}r=a,y=l}if(u<r||u>i){if(c(y)===c(p))break;const t=50,e=.25,n=p-y,s=i-r;if(h=0===n?a-(r+.5*s):Math.abs(n/Math.min(y,p))>t?a-(r+s*(.5+(Math.abs(y)<Math.abs(p)?-e:e))):a-(r-y/n*s),u=a-h,b())break}}d=a-u,a=u}return a}clone(){const t=new h;return t.coefs=this.coefs.slice(),t}eval(t){if(isNaN(t))throw new TypeError(`Parameter must be a number. Found '${t}'`);let e=0;for(let n=this.coefs.length-1;n>=0;n--)e=e*t+this.coefs[n];return e}add(t){const e=new h,n=this.getDegree(),s=t.getDegree(),r=Math.max(n,s);for(let i=0;i<=r;i++){const r=i<=n?this.coefs[i]:0,a=i<=s?t.coefs[i]:0;e.coefs[i]=r+a}return e}multiply(t){const e=new h;for(let n=0;n<=this.getDegree()+t.getDegree();n++)e.coefs.push(0);for(let n=0;n<=this.getDegree();n++)for(let s=0;s<=t.getDegree();s++)e.coefs[n+s]+=this.coefs[n]*t.coefs[s];return e}divideEqualsScalar(t){for(let e=0;e<this.coefs.length;e++)this.coefs[e]/=t}simplifyEquals(t=1e-12){for(let e=this.getDegree();e>=0&&Math.abs(this.coefs[e])<=t;e--)this.coefs.pop()}removeZerosEquals(t=1e-15){const e=this.coefs,n=10*t*Math.abs(e.reduce((t,e)=>Math.abs(e)>Math.abs(t)?e:t));for(let s=0;s<e.length-1;s++)Math.abs(e[s])<n&&(e[s]=0);return this}monicEquals(){const t=this.coefs;return 1!==t[t.length-1]&&this.divideEqualsScalar(t[t.length-1]),this}toString(){const t=[],e=[];for(let s=this.coefs.length-1;s>=0;s--){let n=Math.round(1e3*this.coefs[s])/1e3;if(0!==n){const r=n<0?" - ":" + ";n=Math.abs(n),s>0&&(1===n?n=this._variable:n+=this._variable),s>1&&(n+="^"+s),e.push(r),t.push(n)}}e[0]=" + "===e[0]?"":"-";let n="";for(let s=0;s<t.length;s++)n+=e[s]+t[s];return n}bisection(t,e,n=1e-6,s=15){let r,i=this.eval(t),a=this.eval(e);if(Math.abs(i)<=n)r=t;else if(Math.abs(a)<=n)r=e;else if(i*a<=0){const o=Math.log(e-t),c=Math.LN10*s,h=Math.ceil((o+c)/Math.LN2);for(let s=0;s<h;s++){r=.5*(t+e);const s=this.eval(r);if(Math.abs(s)<=n)break;s*i<0?(e=r,a=s):(t=r,i=s)}}return r}trapezoid(t,e,n){if(isNaN(t)||isNaN(e)||isNaN(n))throw new TypeError("Parameters must be numbers");const s=e-t;if(1===n){const n=this.eval(t),r=this.eval(e);this._s=.5*s*(n+r)}else{const e=1<<n-2,r=s/e;let i=t+.5*r,a=0;for(let t=0;t<e;t++)a+=this.eval(i),i+=r;this._s=.5*(this._s+s*a/e)}if(isNaN(this._s))throw new TypeError("this._s is NaN");return this._s}simpson(t,e){if(isNaN(t)||isNaN(e))throw new TypeError("Parameters must be numbers");const n=e-t;let s=.5*n*(this.eval(t)+this.eval(e)),r=s,i=4*s/3,a=i,o=s;let c=1;for(let h=2;h<=20;h++){const e=n/c;let h=t+.5*e,u=0;for(let t=1;t<=c;t++)u+=this.eval(h),h+=e;if(i=(4*(s=r=.5*(r+n*u/c))-o)/3,Math.abs(i-a)<1e-7*Math.abs(a))break;a=i,o=s,c<<=1}return i}romberg(t,e){if(isNaN(t)||isNaN(e))throw new TypeError("Parameters must be numbers");const n=new Array(21),s=new Array(21);let r={y:0,dy:0};s[0]=1;for(let i=1;i<=20&&(n[i-1]=this.trapezoid(t,e,i),!(i>=3&&(r=h.interpolate(s,n,3,i-3,0),Math.abs(r.dy)<=1e-6*r.y)));i++)n[i]=n[i-1],s[i]=.25*s[i-1];return r.y}zeroErrorEstimate(t){const e=this;if("undefined"===typeof t){const n=e.bounds();t=Math.max(Math.abs(n.minX),Math.abs(n.maxX))}if(t<.001)return 2*Math.abs(e.eval(1e-15));const n=e.coefs.length-1,s=e.coefs[n];return 10*1e-15*e.coefs.reduce((e,n,r)=>{const i=n/s*Math.pow(t,r);return i>e?i:e},0)}boundsUpperRealFujiwara(){let t=this.coefs;const e=t.length-1,n=t[e];1!==n&&(t=this.coefs.map(t=>t/n));const s=t.map((t,n)=>n<e?Math.pow(Math.abs(0===n?t/2:t),1/(e-n)):t);let r;const i=function(t,e,n){return r(n)&&(t.max<e?(t.nearmax=t.max,t.max=e):t.nearmax<e&&(t.nearmax=e)),t};r=function(n){return n<e&&t[n]<0};const a=s.reduce(i,{max:0,nearmax:0});return r=function(n){return n<e&&(e%2===n%2?t[n]<0:t[n]>0)},{negX:-2*s.reduce(i,{max:0,nearmax:0}).max,posX:2*a.max}}boundsLowerRealFujiwara(){const t=new h;t.coefs=this.coefs.slice().reverse();const e=t.boundsUpperRealFujiwara();return e.negX=1/e.negX,e.posX=1/e.posX,e}bounds(){const t=this.boundsUpperRealFujiwara(),e={minX:t.negX,maxX:t.posX};return 0===t.negX&&0===t.posX?e:(0===t.negX?e.minX=this.boundsLowerRealFujiwara().posX:0===t.posX&&(e.maxX=this.boundsLowerRealFujiwara().negX),e.minX>e.maxX&&(e.minX=e.maxX=0),e)}boundUpperAbsRouche(){const t=this.coefs,e=t.length-1;return 1+t.reduce((t,n,s)=>s!==e&&t<(n=Math.abs(n))?n:t,0)/Math.abs(t[e])}boundLowerAbsRouche(){const t=this.coefs,e=t.reduce((t,e,n)=>0!==n&&t<(e=Math.abs(e))?e:t,0);return Math.abs(t[0])/(Math.abs(t[0])+e)}boundsRealLaguerre(){const t=this.coefs,e=t.length-1,n=-t[e-1]/(e*t[e]),s=t[e-1]*t[e-1]-2*e/(e-1)*t[e]*t[e-2];let r=(e-1)/(e*t[e])*Math.sqrt(s);return r<0&&(r=-r),{minX:n-r,maxX:n+r}}countRootsDescartes(){const t=this.coefs,e=t.length-1,n=t.reduce((t,e,n)=>(0!==t.prev_a&&0!==e&&(t.prev_a<0===e>0&&t.pos++,n%2===0!==t.prev_a<0===(n%2===1!==e>0)&&t.neg++),t.prev_a=e,t),{pos:0,neg:0,prev_a:0});return{maxRealPos:n.pos,maxRealNeg:n.neg,minComplex:e-(n.pos+n.neg)}}getDegree(){return this.coefs.length-1}getDerivative(){const t=new h;for(let e=1;e<this.coefs.length;e++)t.coefs.push(e*this.coefs[e]);return t}getRoots(){let t;switch(this.simplifyEquals(),this.getDegree()){case 0:t=[];break;case 1:t=this.getLinearRoot();break;case 2:t=this.getQuadraticRoots();break;case 3:t=this.getCubicRoots();break;case 4:t=this.getQuarticRoots();break;default:t=[]}return t}getRootsInInterval(t,e){const n=[];function s(t){"number"===typeof t&&n.push(t)}if(0===this.getDegree())throw new RangeError("Unexpected empty polynomial");if(1===this.getDegree())s(this.bisection(t,e));else{const n=this.getDerivative().getRootsInInterval(t,e);if(n.length>0){s(this.bisection(t,n[0]));for(let t=0;t<=n.length-2;t++)s(this.bisection(n[t],n[t+1]));s(this.bisection(n[n.length-1],e))}else s(this.bisection(t,e))}return n}getLinearRoot(){const t=[],e=this.coefs[1];return 0!==e&&t.push(-this.coefs[0]/e),t}getQuadraticRoots(){const t=[];if(2===this.getDegree()){const e=this.coefs[2],n=this.coefs[1]/e,s=n*n-4*(this.coefs[0]/e);if(s>0){const e=Math.sqrt(s);t.push(.5*(-n+e)),t.push(.5*(-n-e))}else 0===s&&t.push(.5*-n)}return t}getCubicRoots(){const t=[];if(3===this.getDegree()){const e=this.coefs[3],n=this.coefs[2]/e,s=this.coefs[1]/e,r=(3*s-n*n)/3,i=(2*n*n*n-9*s*n+27*(this.coefs[0]/e))/27,a=n/3;let o=i*i/4+r*r*r/27;const c=i/2,h=this.zeroErrorEstimate();if(Math.abs(o)<=h&&(o=0),o>0){const e=Math.sqrt(o);let n,s=-c+e;n=s>=0?Math.pow(s,1/3):-Math.pow(-s,1/3),(s=-c-e)>=0?n+=Math.pow(s,1/3):n-=Math.pow(-s,1/3),t.push(n-a)}else if(o<0){const e=Math.sqrt(-r/3),n=Math.atan2(Math.sqrt(-o),-c)/3,s=Math.cos(n),i=Math.sin(n),h=Math.sqrt(3);t.push(2*e*s-a),t.push(-e*(s+h*i)-a),t.push(-e*(s-h*i)-a)}else{let e;e=c>=0?-Math.pow(c,1/3):Math.pow(-c,1/3),t.push(2*e-a),t.push(-e-a)}}return t}getQuarticRoots(){let t=[];const e=this.getDegree();if(4===e){const n=new h;n.coefs=this.coefs.slice(),n.divideEqualsScalar(n.coefs[e]);const s=1e-15;Math.abs(n.coefs[0])<10*s*Math.abs(n.coefs[3])&&(n.coefs[0]=0);const r=n.getDerivative(),i=r.getRoots().sort((t,e)=>t-e),a=[],o=i.length-1,u=this.bounds(),l=Math.max(Math.abs(u.minX),Math.abs(u.maxX)),y=this.zeroErrorEstimate(l);for(let t=0;t<=o;t++)a.push(n.eval(i[t]));for(let t=0;t<=o;t++)Math.abs(a[t])<y&&(a[t]=0);let p=0;const x=Math.max(.1*(u.maxX-u.minX)/e,s),d=[],m=[];if(o>-1){for(0!==a[0]?c(a[0])!==c(n.eval(i[0]-x)-a[0])&&(d.push(i[0]-x),m.push([u.minX,i[0]])):(t.push(i[0],i[0]),p++);p<o;p++)0===a[p+1]?(t.push(i[p+1],i[p+1]),p++):c(a[p])!==c(a[p+1])&&(d.push((i[p]+i[p+1])/2),m.push([i[p],i[p+1]]));0!==a[o]&&c(a[o])!==c(n.eval(i[o]+x)-a[o])&&(d.push(i[o]+x),m.push([i[o],u.maxX]))}const f=function(t){return n.eval(t)},b=function(t){return r.eval(t)};if(d.length>0)for(p=0;p<d.length;p++)d[p]=h.newtonSecantBisection(d[p],f,b,32,m[p][0],m[p][1]);t=t.concat(d)}return t}}var u=h;var l=function(){var t=function(t,e,n,s){for(n=n||{},s=t.length;s--;n[t[s]]=e);return n},e=[1,6],n=[1,17],s=[1,7],r=[1,10],i=[1,13],a=[1,28],o=[1,14],c=[1,34],h=[1,15],u=[1,33],l=[1,21],y=[1,24],p=[1,25],x=[1,29],d=[1,30],m=[1,32],f=[1,31],b=[1,5],g=[1,5,14,16,24,28,41],w=[1,57],v=[1,59],P=[1,58],E=[1,46],M=[1,52],k=[1,41],A=[1,42],R=[1,43],T=[1,44],I=[1,45],_=[1,47],X=[1,49],$=[1,50],N=[1,55],Y=[1,56],C=[1,5,14,16,24,28,41,54],L=[1,5,14,16,24,28,31,32,33,34,41,54],O=[1,5,14,16,24,28,31,32,33,34,38,40,41,54],S=[1,5,14,16,24,28,31,32,33,34,38,40,41,54,58],j=[1,5,14,16,24,28,41,58],D=[1,93],B=[1,98],z=[1,112],q=[1,115],U=[14,41],F=[14,28],Q=[1,127],G=[14,24,41],V=[14,24,41,58],Z=[14,28,58],H=[14,24],W=[1,5,14,28,41],J=[1,151],K={trace:function(){},yy:{},symbols_:{error:2,program:3,statements:4,";":5,statement:6,assignment:7,sequence:8,LET:9,IDENTIFIER:10,"=":11,DEF:12,sequences:13,",":14,steps:15,"|>":16,step:17,"=~":18,namedPattern:19,expression:20,mathExpression:21,MAP:22,"(":23,")":24,PATTERNS:25,"{":26,patterns:27,"}":28,SEQUENCES:29,callExpression:30,"+":31,"-":32,"*":33,"/":34,argumentList:35,memberExpression:36,primaryExpression:37,".":38,integer:39,"[":40,"]":41,boolean:42,NULL_TYPE:43,float:44,string:45,UNDEFINED_TYPE:46,$:47,arrayExpression:48,objectExpression:49,expressionElements:50,expressionElement:51,expressionProperties:52,expressionProperty:53,":":54,argument:55,"...":56,pattern:57,AS:58,ANY_TYPE:59,ARRAY_TYPE:60,BOOLEAN_TYPE:61,TRUE:62,FALSE:63,NUMBER_TYPE:64,OBJECT_TYPE:65,STRING_TYPE:66,arrayPattern:67,objectPattern:68,PATTERN:69,ENUMERATION:70,patternElements:71,namedPatternElement:72,patternElement:73,range:74,"..":75,patternProperties:76,namedPatternProperty:77,namedProperty:78,STRING:79,NUMBER:80,stringOrIdentifier:81,identifiers:82,$accept:0,$end:1},terminals_:{2:"error",5:";",9:"LET",10:"IDENTIFIER",11:"=",12:"DEF",14:",",16:"|>",18:"=~",22:"MAP",23:"(",24:")",25:"PATTERNS",26:"{",28:"}",29:"SEQUENCES",31:"+",32:"-",33:"*",34:"/",38:".",40:"[",41:"]",43:"NULL_TYPE",46:"UNDEFINED_TYPE",47:"$",54:":",56:"...",58:"AS",59:"ANY_TYPE",60:"ARRAY_TYPE",61:"BOOLEAN_TYPE",62:"TRUE",63:"FALSE",64:"NUMBER_TYPE",65:"OBJECT_TYPE",66:"STRING_TYPE",69:"PATTERN",70:"ENUMERATION",75:"..",79:"STRING",80:"NUMBER"},productions_:[0,[3,1],[3,2],[4,3],[4,1],[6,1],[6,1],[7,4],[7,4],[13,3],[13,1],[8,1],[15,3],[15,1],[17,2],[17,1],[20,1],[20,6],[20,4],[20,4],[21,1],[21,3],[21,3],[21,3],[21,3],[30,3],[30,4],[30,1],[36,1],[36,3],[36,3],[36,4],[37,1],[37,1],[37,1],[37,1],[37,1],[37,1],[37,1],[37,1],[37,1],[37,3],[48,2],[48,3],[50,3],[50,1],[51,1],[51,1],[49,2],[49,3],[52,3],[52,1],[53,3],[53,1],[53,1],[35,3],[35,1],[55,1],[55,2],[27,3],[27,1],[19,1],[19,3],[57,1],[57,1],[57,1],[57,1],[57,1],[57,1],[57,1],[57,1],[57,1],[57,1],[57,1],[57,1],[57,1],[57,1],[57,2],[57,2],[57,1],[67,2],[67,3],[71,3],[71,1],[72,1],[72,3],[73,1],[73,3],[73,3],[73,5],[74,3],[74,2],[74,2],[74,1],[68,2],[68,3],[76,3],[76,1],[77,1],[77,3],[78,3],[78,1],[42,1],[42,1],[45,1],[39,1],[44,1],[81,1],[81,1],[82,3],[82,1]],performAction:function(t,e,n,s,r,i,a){var o=i.length-1;switch(r){case 1:return i[o];case 2:return i[o-1];case 3:case 9:case 12:case 44:case 50:case 55:case 59:case 82:case 96:case 109:i[o-2].push(i[o]),this.$=i[o-2];break;case 4:case 10:case 13:case 45:case 51:case 56:case 60:case 83:case 97:case 110:this.$=[i[o]];break;case 5:case 6:case 14:case 15:case 16:case 20:case 27:case 28:case 39:case 40:case 46:case 47:case 54:case 57:case 98:case 107:this.$=i[o];break;case 7:this.$={type:"assignment",name:i[o-2],value:i[o]};break;case 8:this.$={type:"def",name:i[o-2],value:i[o]};break;case 11:this.$={type:"sequence",steps:i[o]};break;case 17:this.$={type:"map",value:[i[o-3],i[o-1]]};break;case 18:this.$={type:"patterns",patterns:i[o-1]};break;case 19:this.$={type:"sequences",sequences:i[o-1]};break;case 21:this.$={type:"add",left:i[o-2],right:i[o]};break;case 22:this.$={type:"subtract",left:i[o-2],right:i[o]};break;case 23:this.$={type:"multiply",left:i[o-2],right:i[o]};break;case 24:this.$={type:"divide",left:i[o-2],right:i[o]};break;case 25:this.$={type:"invoke",name:i[o-2],args:[]};break;case 26:this.$={type:"invoke",name:i[o-3],args:i[o-1]};break;case 29:this.$={type:"get-property",left:i[o-2],right:i[o]};break;case 30:this.$={type:"get-index",left:i[o-2],right:i[o]};break;case 31:this.$={type:"get-index",left:i[o-3],right:i[o-1]};break;case 32:this.$={type:"boolean",value:i[o]};break;case 33:this.$={type:"boolean",value:null};break;case 34:this.$={type:"number",value:i[o]};break;case 35:this.$={type:"string",value:i[o]};break;case 36:this.$={type:"undefined",value:void 0};break;case 37:this.$={type:"get-value",name:i[o]};break;case 38:this.$={type:"get-structure"};break;case 41:this.$=i[o-1];break;case 42:this.$={type:"array",value:[]};break;case 43:this.$={type:"array",value:i[o-1]};break;case 48:this.$={type:"object",value:[]};break;case 49:this.$={type:"object",value:i[o-1]};break;case 52:this.$={type:"property",name:i[o-2],value:i[o]};break;case 53:this.$={type:"property",name:i[o],value:null};break;case 58:this.$={type:"spread",expression:i[o]};break;case 61:case 84:i[o].assignTo=null,this.$=i[o];break;case 62:case 85:case 99:i[o-2].assignTo=i[o],this.$=i[o-2];break;case 63:this.$={type:"pattern",patternType:"any",value:null};break;case 64:this.$={type:"pattern",patternType:"array",value:null};break;case 65:this.$={type:"pattern",patternType:"boolean",value:null};break;case 66:this.$={type:"pattern",patternType:"boolean",value:!0};break;case 67:this.$={type:"pattern",patternType:"boolean",value:!1};break;case 68:this.$={type:"pattern",patternType:"null",value:null};break;case 69:this.$={type:"pattern",patternType:"number",value:null};break;case 70:this.$={type:"pattern",patternType:"number",value:i[o]};break;case 71:this.$={type:"pattern",patternType:"object",value:null};break;case 72:this.$={type:"pattern",patternType:"string",value:null};break;case 73:this.$={type:"pattern",patternType:"string",value:i[o]};break;case 74:this.$={type:"pattern",patternType:"undefined",value:null};break;case 75:case 76:this.$=i[o];break;case 77:this.$={type:"pattern-reference",name:i[o]};break;case 78:this.$={type:"enumeration-reference",name:i[o]};break;case 79:this.$={type:"pattern",patternType:"reference",value:i[o]};break;case 80:this.$={type:"pattern",patternType:"array-pattern",value:[]};break;case 81:this.$={type:"pattern",patternType:"array-pattern",value:i[o-1]};break;case 86:this.$={type:"element",pattern:i[o],range:{type:"range",start:1,stop:1}};break;case 87:this.$={type:"element",pattern:i[o-2],range:i[o]};break;case 88:this.$={type:"element-group",elements:i[o-1],range:{type:"range",start:1,stop:1}};break;case 89:this.$={type:"element-group",elements:i[o-3],range:i[o]};break;case 90:this.$={type:"range",start:i[o-2],stop:i[o]};break;case 91:this.$={type:"range",start:0,stop:i[o]};break;case 92:this.$={type:"range",start:i[o-1],stop:1/0};break;case 93:this.$={type:"range",start:i[o],stop:i[o]};break;case 94:this.$={type:"pattern",patternType:"object",value:null};break;case 95:this.$={type:"pattern",patternType:"object-pattern",value:i[o-1]};break;case 100:this.$={type:"property",name:i[o-2],pattern:i[o]};break;case 101:this.$={type:"property",name:i[o],pattern:{type:"pattern",patternType:"any",value:null}};break;case 102:this.$=!0;break;case 103:this.$=!1;break;case 104:case 108:this.$=i[o].substring(1,i[o].length-1);break;case 105:this.$=parseInt(i[o]);break;case 106:this.$=parseFloat(i[o])}},table:[{3:1,4:2,6:3,7:4,8:5,9:e,10:n,12:s,15:8,17:9,18:r,20:11,21:12,22:i,23:a,25:o,26:c,29:h,30:16,36:18,37:19,40:u,42:20,43:l,44:22,45:23,46:y,47:p,48:26,49:27,62:x,63:d,79:m,80:f},{1:[3]},{1:[2,1],5:[1,35]},t(b,[2,4]),t(b,[2,5]),t(b,[2,6]),{10:[1,36]},{10:[1,37]},t([1,5,14,24,28,41],[2,11],{16:[1,38]}),t(g,[2,13]),{10:w,19:39,26:v,40:P,43:E,44:48,45:51,46:M,57:40,59:k,60:A,61:R,62:T,63:I,64:_,65:X,66:$,67:53,68:54,69:N,70:Y,79:m,80:f},t(g,[2,15]),t(C,[2,16],{31:[1,60],32:[1,61],33:[1,62],34:[1,63]}),{23:[1,64]},{26:[1,65]},{26:[1,66]},t(L,[2,20]),t(O,[2,37],{23:[1,67]}),t(L,[2,27],{38:[1,68],40:[1,69]}),t(O,[2,28]),t(O,[2,32]),t(O,[2,33]),t(O,[2,34]),t(O,[2,35]),t(O,[2,36]),t(O,[2,38]),t(O,[2,39]),t(O,[2,40]),{10:n,20:70,21:12,22:i,23:a,25:o,26:c,29:h,30:16,36:18,37:19,40:u,42:20,43:l,44:22,45:23,46:y,47:p,48:26,49:27,62:x,63:d,79:m,80:f},t(O,[2,102]),t(O,[2,103]),t(S,[2,106]),t(S,[2,104]),{7:75,9:e,10:n,12:s,20:74,21:12,22:i,23:a,25:o,26:c,29:h,30:16,36:18,37:19,40:u,41:[1,71],42:20,43:l,44:22,45:23,46:y,47:p,48:26,49:27,50:72,51:73,62:x,63:d,79:m,80:f},{7:80,9:e,10:n,12:s,20:79,21:12,22:i,23:a,25:o,26:c,28:[1,76],29:h,30:16,36:18,37:19,40:u,42:20,43:l,44:22,45:23,46:y,47:p,48:26,49:27,52:77,53:78,62:x,63:d,79:m,80:f},{1:[2,2],6:81,7:4,8:5,9:e,10:n,12:s,15:8,17:9,18:r,20:11,21:12,22:i,23:a,25:o,26:c,29:h,30:16,36:18,37:19,40:u,42:20,43:l,44:22,45:23,46:y,47:p,48:26,49:27,62:x,63:d,79:m,80:f},{11:[1,82]},{11:[1,83]},{10:n,17:84,18:r,20:11,21:12,22:i,23:a,25:o,26:c,29:h,30:16,36:18,37:19,40:u,42:20,43:l,44:22,45:23,46:y,47:p,48:26,49:27,62:x,63:d,79:m,80:f},t(g,[2,14]),t(g,[2,61],{58:[1,85]}),t(j,[2,63]),t(j,[2,64]),t(j,[2,65]),t(j,[2,66]),t(j,[2,67]),t(j,[2,68]),t(j,[2,69]),t(j,[2,70]),t(j,[2,71]),t(j,[2,72]),t(j,[2,73]),t(j,[2,74]),t(j,[2,75]),t(j,[2,76]),{10:[1,86]},{10:[1,87]},t(j,[2,79]),{10:w,23:D,26:v,40:P,41:[1,88],43:E,44:48,45:51,46:M,57:92,59:k,60:A,61:R,62:T,63:I,64:_,65:X,66:$,67:53,68:54,69:N,70:Y,71:89,72:90,73:91,79:m,80:f},{10:B,28:[1,94],76:95,77:96,78:97},{10:n,23:a,26:c,30:99,36:18,37:19,40:u,42:20,43:l,44:22,45:23,46:y,47:p,48:26,49:27,62:x,63:d,79:m,80:f},{10:n,23:a,26:c,30:100,36:18,37:19,40:u,42:20,43:l,44:22,45:23,46:y,47:p,48:26,49:27,62:x,63:d,79:m,80:f},{10:n,23:a,26:c,30:101,36:18,37:19,40:u,42:20,43:l,44:22,45:23,46:y,47:p,48:26,49:27,62:x,63:d,79:m,80:f},{10:n,23:a,26:c,30:102,36:18,37:19,40:u,42:20,43:l,44:22,45:23,46:y,47:p,48:26,49:27,62:x,63:d,79:m,80:f},{10:n,20:103,21:12,22:i,23:a,25:o,26:c,29:h,30:16,36:18,37:19,40:u,42:20,43:l,44:22,45:23,46:y,47:p,48:26,49:27,62:x,63:d,79:m,80:f},{10:w,19:105,26:v,27:104,40:P,43:E,44:48,45:51,46:M,57:40,59:k,60:A,61:R,62:T,63:I,64:_,65:X,66:$,67:53,68:54,69:N,70:Y,79:m,80:f},{8:107,10:n,13:106,15:8,17:9,18:r,20:11,21:12,22:i,23:a,25:o,26:c,29:h,30:16,36:18,37:19,40:u,42:20,43:l,44:22,45:23,46:y,47:p,48:26,49:27,62:x,63:d,79:m,80:f},{10:n,20:111,21:12,22:i,23:a,24:[1,108],25:o,26:c,29:h,30:16,35:109,36:18,37:19,40:u,42:20,43:l,44:22,45:23,46:y,47:p,48:26,49:27,55:110,56:z,62:x,63:d,79:m,80:f},{10:[1,113],39:114,80:q},{39:116,80:q},{24:[1,117]},t(O,[2,42]),{14:[1,119],41:[1,118]},t(U,[2,45]),t(U,[2,46]),t(U,[2,47]),t(O,[2,48]),{14:[1,121],28:[1,120]},t(F,[2,51]),t(F,[2,53],{54:[1,122]}),t(F,[2,54]),t(b,[2,3]),{8:123,10:n,15:8,17:9,18:r,20:11,21:12,22:i,23:a,25:o,26:c,29:h,30:16,36:18,37:19,40:u,42:20,43:l,44:22,45:23,46:y,47:p,48:26,49:27,62:x,63:d,79:m,80:f},{8:124,10:n,15:8,17:9,18:r,20:11,21:12,22:i,23:a,25:o,26:c,29:h,30:16,36:18,37:19,40:u,42:20,43:l,44:22,45:23,46:y,47:p,48:26,49:27,62:x,63:d,79:m,80:f},t(g,[2,12]),{10:[1,125]},t(j,[2,77]),t(j,[2,78]),t(j,[2,80]),{14:Q,41:[1,126]},t(G,[2,83]),t(G,[2,84],{58:[1,128]}),t(V,[2,86],{5:[1,129]}),{10:w,23:D,26:v,40:P,43:E,44:48,45:51,46:M,57:92,59:k,60:A,61:R,62:T,63:I,64:_,65:X,66:$,67:53,68:54,69:N,70:Y,71:130,72:90,73:91,79:m,80:f},t(j,[2,94]),{14:[1,132],28:[1,131]},t(F,[2,97]),t(F,[2,98],{58:[1,133]}),t(Z,[2,101],{54:[1,134]}),t(L,[2,21]),t(L,[2,22]),t(L,[2,23]),t(L,[2,24]),{14:[1,135]},{14:[1,137],28:[1,136]},t(F,[2,60]),{14:[1,139],28:[1,138]},t(F,[2,10]),t(L,[2,25]),{14:[1,141],24:[1,140]},t(H,[2,56]),t(H,[2,57]),{10:n,20:142,21:12,22:i,23:a,25:o,26:c,29:h,30:16,36:18,37:19,40:u,42:20,43:l,44:22,45:23,46:y,47:p,48:26,49:27,62:x,63:d,79:m,80:f},t(O,[2,29]),t(O,[2,30]),t([1,5,14,16,24,28,31,32,33,34,38,40,41,54,58,75],[2,105]),{41:[1,143]},t(O,[2,41]),t(O,[2,43]),{7:75,9:e,10:n,12:s,20:74,21:12,22:i,23:a,25:o,26:c,29:h,30:16,36:18,37:19,40:u,42:20,43:l,44:22,45:23,46:y,47:p,48:26,49:27,51:144,62:x,63:d,79:m,80:f},t(O,[2,49]),{7:80,9:e,10:n,12:s,20:79,21:12,22:i,23:a,25:o,26:c,29:h,30:16,36:18,37:19,40:u,42:20,43:l,44:22,45:23,46:y,47:p,48:26,49:27,53:145,62:x,63:d,79:m,80:f},{8:146,10:n,15:8,17:9,18:r,20:11,21:12,22:i,23:a,25:o,26:c,29:h,30:16,36:18,37:19,40:u,42:20,43:l,44:22,45:23,46:y,47:p,48:26,49:27,62:x,63:d,79:m,80:f},t(W,[2,7]),t(W,[2,8]),t(g,[2,62]),t(j,[2,81]),{10:w,23:D,26:v,40:P,43:E,44:48,45:51,46:M,57:92,59:k,60:A,61:R,62:T,63:I,64:_,65:X,66:$,67:53,68:54,69:N,70:Y,72:147,73:91,79:m,80:f},{10:[1,148]},{39:150,74:149,75:J,80:q},{14:Q,24:[1,152]},t(j,[2,95]),{10:B,77:153,78:97},{10:[1,154]},{10:w,26:v,40:P,43:E,44:48,45:51,46:M,57:155,59:k,60:A,61:R,62:T,63:I,64:_,65:X,66:$,67:53,68:54,69:N,70:Y,79:m,80:f},{8:156,10:n,15:8,17:9,18:r,20:11,21:12,22:i,23:a,25:o,26:c,29:h,30:16,36:18,37:19,40:u,42:20,43:l,44:22,45:23,46:y,47:p,48:26,49:27,62:x,63:d,79:m,80:f},t(C,[2,18]),{10:w,19:157,26:v,40:P,43:E,44:48,45:51,46:M,57:40,59:k,60:A,61:R,62:T,63:I,64:_,65:X,66:$,67:53,68:54,69:N,70:Y,79:m,80:f},t(C,[2,19]),{8:158,10:n,15:8,17:9,18:r,20:11,21:12,22:i,23:a,25:o,26:c,29:h,30:16,36:18,37:19,40:u,42:20,43:l,44:22,45:23,46:y,47:p,48:26,49:27,62:x,63:d,79:m,80:f},t(L,[2,26]),{10:n,20:111,21:12,22:i,23:a,25:o,26:c,29:h,30:16,36:18,37:19,40:u,42:20,43:l,44:22,45:23,46:y,47:p,48:26,49:27,55:159,56:z,62:x,63:d,79:m,80:f},t(H,[2,58]),t(O,[2,31]),t(U,[2,44]),t(F,[2,50]),t(F,[2,52]),t(G,[2,82]),t(G,[2,85]),t(V,[2,87]),t(V,[2,93],{75:[1,160]}),{39:161,80:q},t(V,[2,88],{5:[1,162]}),t(F,[2,96]),t(F,[2,99]),t(Z,[2,100]),{24:[1,163]},t(F,[2,59]),t(F,[2,9]),t(H,[2,55]),t(V,[2,92],{39:164,80:q}),t(V,[2,91]),{39:150,74:165,75:J,80:q},t(C,[2,17]),t(V,[2,90]),t(V,[2,89])],defaultActions:{},parseError:function(t,e){if(!e.recoverable){var n=new Error(t);throw n.hash=e,n}this.trace(t)},parse:function(t){var e=this,n=[0],s=[null],r=[],i=this.table,a="",o=0,c=0,h=0,u=r.slice.call(arguments,1),l=Object.create(this.lexer),y={yy:{}};for(var p in this.yy)Object.prototype.hasOwnProperty.call(this.yy,p)&&(y.yy[p]=this.yy[p]);l.setInput(t,y.yy),y.yy.lexer=l,y.yy.parser=this,"undefined"==typeof l.yylloc&&(l.yylloc={});var x=l.yylloc;r.push(x);var d=l.options&&l.options.ranges;"function"===typeof y.yy.parseError?this.parseError=y.yy.parseError:this.parseError=Object.getPrototypeOf(this).parseError;for(var m,f,b,g,w,v,P,E,M,k=function(){var t;return"number"!==typeof(t=l.lex()||1)&&(t=e.symbols_[t]||t),t},A={};;){if(b=n[n.length-1],this.defaultActions[b]?g=this.defaultActions[b]:(null!==m&&"undefined"!=typeof m||(m=k()),g=i[b]&&i[b][m]),"undefined"===typeof g||!g.length||!g[0]){var R="";for(v in M=[],i[b])this.terminals_[v]&&v>2&&M.push("'"+this.terminals_[v]+"'");R=l.showPosition?"Parse error on line "+(o+1)+":\n"+l.showPosition()+"\nExpecting "+M.join(", ")+", got '"+(this.terminals_[m]||m)+"'":"Parse error on line "+(o+1)+": Unexpected "+(1==m?"end of input":"'"+(this.terminals_[m]||m)+"'"),this.parseError(R,{text:l.match,token:this.terminals_[m]||m,line:l.yylineno,loc:x,expected:M})}if(g[0]instanceof Array&&g.length>1)throw new Error("Parse Error: multiple actions possible at state: "+b+", token: "+m);switch(g[0]){case 1:n.push(m),s.push(l.yytext),r.push(l.yylloc),n.push(g[1]),m=null,f?(m=f,f=null):(c=l.yyleng,a=l.yytext,o=l.yylineno,x=l.yylloc,h>0&&h--);break;case 2:if(P=this.productions_[g[1]][1],A.$=s[s.length-P],A._$={first_line:r[r.length-(P||1)].first_line,last_line:r[r.length-1].last_line,first_column:r[r.length-(P||1)].first_column,last_column:r[r.length-1].last_column},d&&(A._$.range=[r[r.length-(P||1)].range[0],r[r.length-1].range[1]]),"undefined"!==typeof(w=this.performAction.apply(A,[a,c,o,y.yy,g[1],s,r].concat(u))))return w;P&&(n=n.slice(0,-1*P*2),s=s.slice(0,-1*P),r=r.slice(0,-1*P)),n.push(this.productions_[g[1]][0]),s.push(A.$),r.push(A._$),E=i[n[n.length-2]][n[n.length-1]],n.push(E);break;case 3:return!0}}return!0}},tt={EOF:1,parseError:function(t,e){if(!this.yy.parser)throw new Error(t);this.yy.parser.parseError(t,e)},setInput:function(t,e){return this.yy=e||this.yy||{},this._input=t,this._more=this._backtrack=this.done=!1,this.yylineno=this.yyleng=0,this.yytext=this.matched=this.match="",this.conditionStack=["INITIAL"],this.yylloc={first_line:1,first_column:0,last_line:1,last_column:0},this.options.ranges&&(this.yylloc.range=[0,0]),this.offset=0,this},input:function(){var t=this._input[0];return this.yytext+=t,this.yyleng++,this.offset++,this.match+=t,this.matched+=t,t.match(/(?:\r\n?|\n).*/g)?(this.yylineno++,this.yylloc.last_line++):this.yylloc.last_column++,this.options.ranges&&this.yylloc.range[1]++,this._input=this._input.slice(1),t},unput:function(t){var e=t.length,n=t.split(/(?:\r\n?|\n)/g);this._input=t+this._input,this.yytext=this.yytext.substr(0,this.yytext.length-e),this.offset-=e;var s=this.match.split(/(?:\r\n?|\n)/g);this.match=this.match.substr(0,this.match.length-1),this.matched=this.matched.substr(0,this.matched.length-1),n.length-1&&(this.yylineno-=n.length-1);var r=this.yylloc.range;return this.yylloc={first_line:this.yylloc.first_line,last_line:this.yylineno+1,first_column:this.yylloc.first_column,last_column:n?(n.length===s.length?this.yylloc.first_column:0)+s[s.length-n.length].length-n[0].length:this.yylloc.first_column-e},this.options.ranges&&(this.yylloc.range=[r[0],r[0]+this.yyleng-e]),this.yyleng=this.yytext.length,this},more:function(){return this._more=!0,this},reject:function(){return this.options.backtrack_lexer?(this._backtrack=!0,this):this.parseError("Lexical error on line "+(this.yylineno+1)+". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n"+this.showPosition(),{text:"",token:null,line:this.yylineno})},less:function(t){this.unput(this.match.slice(t))},pastInput:function(){var t=this.matched.substr(0,this.matched.length-this.match.length);return(t.length>20?"...":"")+t.substr(-20).replace(/\n/g,"")},upcomingInput:function(){var t=this.match;return t.length<20&&(t+=this._input.substr(0,20-t.length)),(t.substr(0,20)+(t.length>20?"...":"")).replace(/\n/g,"")},showPosition:function(){var t=this.pastInput(),e=new Array(t.length+1).join("-");return t+this.upcomingInput()+"\n"+e+"^"},test_match:function(t,e){var n,s,r;if(this.options.backtrack_lexer&&(r={yylineno:this.yylineno,yylloc:{first_line:this.yylloc.first_line,last_line:this.last_line,first_column:this.yylloc.first_column,last_column:this.yylloc.last_column},yytext:this.yytext,match:this.match,matches:this.matches,matched:this.matched,yyleng:this.yyleng,offset:this.offset,_more:this._more,_input:this._input,yy:this.yy,conditionStack:this.conditionStack.slice(0),done:this.done},this.options.ranges&&(r.yylloc.range=this.yylloc.range.slice(0))),(s=t[0].match(/(?:\r\n?|\n).*/g))&&(this.yylineno+=s.length),this.yylloc={first_line:this.yylloc.last_line,last_line:this.yylineno+1,first_column:this.yylloc.last_column,last_column:s?s[s.length-1].length-s[s.length-1].match(/\r?\n?/)[0].length:this.yylloc.last_column+t[0].length},this.yytext+=t[0],this.match+=t[0],this.matches=t,this.yyleng=this.yytext.length,this.options.ranges&&(this.yylloc.range=[this.offset,this.offset+=this.yyleng]),this._more=!1,this._backtrack=!1,this._input=this._input.slice(t[0].length),this.matched+=t[0],n=this.performAction.call(this,this.yy,this,e,this.conditionStack[this.conditionStack.length-1]),this.done&&this._input&&(this.done=!1),n)return n;if(this._backtrack){for(var i in r)this[i]=r[i];return!1}return!1},next:function(){if(this.done)return this.EOF;var t,e,n,s;this._input||(this.done=!0),this._more||(this.yytext="",this.match="");for(var r=this._currentRules(),i=0;i<r.length;i++)if((n=this._input.match(this.rules[r[i]]))&&(!e||n[0].length>e[0].length)){if(e=n,s=i,this.options.backtrack_lexer){if(!1!==(t=this.test_match(n,r[i])))return t;if(this._backtrack){e=!1;continue}return!1}if(!this.options.flex)break}return e?!1!==(t=this.test_match(e,r[s]))&&t:""===this._input?this.EOF:this.parseError("Lexical error on line "+(this.yylineno+1)+". Unrecognized text.\n"+this.showPosition(),{text:"",token:null,line:this.yylineno})},lex:function(){var t=this.next();return t||this.lex()},begin:function(t){this.conditionStack.push(t)},popState:function(){return this.conditionStack.length-1>0?this.conditionStack.pop():this.conditionStack[0]},_currentRules:function(){return this.conditionStack.length&&this.conditionStack[this.conditionStack.length-1]?this.conditions[this.conditionStack[this.conditionStack.length-1]].rules:this.conditions.INITIAL.rules},topState:function(t){return(t=this.conditionStack.length-1-Math.abs(t||0))>=0?this.conditionStack[t]:"INITIAL"},pushState:function(t){this.begin(t)},stateStackSize:function(){return this.conditionStack.length},options:{},performAction:function(t,e,n,s){switch(n){case 0:case 1:break;case 2:return 59;case 3:return 60;case 4:return 58;case 5:return 61;case 6:return 12;case 7:return 70;case 8:return 63;case 9:return 9;case 10:return 22;case 11:return 25;case 12:return 43;case 13:return 64;case 14:return 65;case 15:return 29;case 16:return 66;case 17:return 62;case 18:return 46;case 19:return 80;case 20:return 79;case 21:return 23;case 22:return 24;case 23:return 26;case 24:return 28;case 25:return 40;case 26:return 41;case 27:return 16;case 28:return"|";case 29:return 14;case 30:return 54;case 31:return 5;case 32:return 18;case 33:return 11;case 34:return"<=";case 35:return 56;case 36:return 75;case 37:return 38;case 38:return"_";case 39:return 31;case 40:return 32;case 41:return 33;case 42:return 34;case 43:return 47;case 44:return 10}},rules:[/^(?:\s+)/,/^(?:\/\/.*)/,/^(?:any\b)/,/^(?:array\b)/,/^(?:as\b)/,/^(?:boolean\b)/,/^(?:def\b)/,/^(?:enum\b)/,/^(?:false\b)/,/^(?:let\b)/,/^(?:map\b)/,/^(?:patterns\b)/,/^(?:null\b)/,/^(?:number\b)/,/^(?:object\b)/,/^(?:sequences\b)/,/^(?:string\b)/,/^(?:true\b)/,/^(?:undefined\b)/,/^(?:[-+]?(0|[1-9]\d*)(\.\d+)?)/,/^(?:"[^"\r\n]*")/,/^(?:\()/,/^(?:\))/,/^(?:{)/,/^(?:})/,/^(?:\[)/,/^(?:\])/,/^(?:\|>)/,/^(?:\|)/,/^(?:,)/,/^(?::)/,/^(?:;)/,/^(?:=~)/,/^(?:=)/,/^(?:<=)/,/^(?:\.{3})/,/^(?:\.{2})/,/^(?:\.)/,/^(?:_)/,/^(?:\+)/,/^(?:-)/,/^(?:\*)/,/^(?:\/)/,/^(?:\$)/,/^(?:[a-zA-Z_][a-zA-Z0-9_]*)/],conditions:{INITIAL:{rules:[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44],inclusive:!0}}};function et(){this.yy={}}return K.lexer=tt,et.prototype=K,K.Parser=et,new et}();function y(t){switch(t){case null:return"null";case void 0:return"undefined";default:return Array.isArray(t)?"array":typeof t}}function p(t){return Array.isArray(t)?t.length:0}function x(t,e){const n=[];if(Array.isArray(t)&&t.length>0&&t.every(t=>Array.isArray(t))){const s=Math.max(...t.map(t=>t.length));for(let r=0;r<s;r++){const s=[];for(const n of t)s.push(r<n.length?n[r]:e);n.push(s)}}return n}function d(t,e,n,s){const{length:r}=t,i=[];n=void 0===n?e:n,e=Math.max(1,e),n=Math.max(1,n);for(let a=0;a<r;a+=n){const n=[];let o=a;for(let i=0;i<e;i++,o++)n.push(o<r?t[o]:s);i.push(n)}return i}function m(t){return Array.isArray(t)?t.slice().reverse():void 0}function f(t,e){return Array.isArray(t)?t.slice().sort(e):void 0}function b(t,e){return t.join(e)}function g(t){return null!==t&&"object"===typeof t}function w(t){return g(t)?Object.keys(t):[]}function v(t){return g(t)?Object.values(t):[]}function P(t){return g(t)?Object.entries(t):[]}function E(t){const e={};if(Array.isArray(t))for(const n of t)if(n.length>=2){const[t,s]=n;e[t]=s}return e}function M(...t){return t.length>0&&Array.isArray(t[0])?t[0].concat(...t.slice(1)):t.every(t=>g(t))?Object.assign({},...t):void 0}const k={};function A(t){return null!==t&&"object"===typeof t}class R{constructor(t,e){this.type=t,this.text=e}typeis(t){return this.type===t}}R.UNDEFINED=0,R.COMMAND=1,R.NUMBER=2,R.EOD=3;var T=R;var I=class{constructor(t){null!==t&&void 0!==t||(t=""),this.setPathData(t)}setPathData(t){if("string"!==typeof t)throw new TypeError("The first parameter must be a string");this._pathData=t}getNextToken(){let t=null,e=this._pathData;for(;null===t;)if(null===e||""===e)t=new T(T.EOD,"");else if(e.match(/^([ \t\r\n,]+)/))e=e.substr(RegExp.$1.length);else if(e.match(/^([AaCcHhLlMmQqSsTtVvZz])/))t=new T(T.COMMAND,RegExp.$1),e=e.substr(RegExp.$1.length);else{if(!e.match(/^(([-+]?\d+(\.\d*)?|[-+]?\.\d+)([eE][-+]?\d+)?)/))throw new SyntaxError(`Unrecognized path data: ${e}`);t=new T(T.NUMBER,RegExp.$1),e=e.substr(RegExp.$1.length)}return this._pathData=e,t}};const _="BOP";class X{constructor(){this._lexer=new I,this._handler=null}parseData(t){if("string"!==typeof t)throw new TypeError(`The first parameter must be a string: ${t}`);null!==this._handler&&"function"===typeof this._handler.beginParse&&this._handler.beginParse();const e=this._lexer;e.setPathData(t);let n=_,s=null,r=e.getNextToken();for(;!1===r.typeis(T.EOD);){let t;const i=[];switch(r.type){case T.COMMAND:if(n===_&&"M"!==r.text&&"m"!==r.text)throw new SyntaxError(`New paths must begin with a moveto command. Found '${r.text}'`);n=r.text,t=X.PARAMCOUNT[r.text.toUpperCase()],r=e.getNextToken();break;case T.NUMBER:if(n===_)throw new SyntaxError(`New paths must begin with a moveto command. Found '${r.text}'`);t=X.PARAMCOUNT[n.toUpperCase()];break;default:throw new SyntaxError(`Unrecognized command type: ${r.type}`)}for(let n=0;n<t;n++){switch(r.type){case T.COMMAND:throw new SyntaxError(`Parameter must be a number. Found '${r.text}'`);case T.NUMBER:i[n]=parseFloat(r.text);break;case T.EOD:throw new SyntaxError("Unexpected end of string");default:throw new SyntaxError(`Unrecognized parameter type. Found type '${r.type}'`)}r=e.getNextToken()}if(null!==this._handler){const t=this._handler,e=X.METHODNAME[n];"a"!==n&&"A"!==n||(i[3]=0!==i[3],i[4]=0!==i[4]),null!==t&&"function"===typeof t[e]&&t[e](...i)}switch(n){case"M":n="L";break;case"m":n="l";break;case"Z":case"z":n="BOP"}if(r===s)throw new SyntaxError(`Parser stalled on '${r.text}'`);s=r}null!==this._handler&&"function"===typeof this._handler.endParse&&this._handler.endParse()}setHandler(t){this._handler=t}}X.PARAMCOUNT={A:7,C:6,H:1,L:2,M:2,Q:4,S:4,T:2,V:1,Z:0},X.METHODNAME={A:"arcAbs",a:"arcRel",C:"curvetoCubicAbs",c:"curvetoCubicRel",H:"linetoHorizontalAbs",h:"linetoHorizontalRel",L:"linetoAbs",l:"linetoRel",M:"movetoAbs",m:"movetoRel",Q:"curvetoQuadraticAbs",q:"curvetoQuadraticRel",S:"curvetoCubicSmoothAbs",s:"curvetoCubicSmoothRel",T:"curvetoQuadraticSmoothAbs",t:"curvetoQuadraticSmoothRel",V:"linetoVerticalAbs",v:"linetoVerticalRel",Z:"closePath",z:"closePath"};var $=X;const N=2*Math.PI;function Y(t,e,n,s,r,i,o){r=r*Math.PI/180;const c=Math.cos(r),h=Math.sin(r),u=t.subtract(e).multiply(.5),l=u.x*c+u.y*h,y=u.x*-h+u.y*c,p=l*l,x=y*y,d=p/((n=Math.abs(n))*n)+x/((s=Math.abs(s))*s);if(d>1){const t=Math.sqrt(d);n*=t,s*=t}const m=n*n,f=s*s,b=m*x,g=f*p;let w=(m*f-b-g)/(b+g);Math.abs(w)<1e-6&&(w=0);let v=Math.sqrt(w);i===o&&(v=-v);const P=t.add(e).multiply(.5),E=v*n*y/s,M=v*-s*l/n,k=(l-E)/n,A=(l+E)/n,R=(y-M)/s,T=(y+M)/s,I=new a(1,0).angleBetween(new a(k,R));let _=function(t){const e=t%N;return e<0?e+N:e}(new a(k,R).angleBetween(new a(-A,-T)));return!1===o&&(_-=N),[E*c-M*h+P.x,E*h+M*c+P.y,n,s,I,I+_]}var C=class{constructor(t){this.shapeCreator=t,this.shapes=[],this.firstX=null,this.firstY=null,this.lastX=null,this.lastY=null,this.lastCommand=null}beginParse(){this.shapes=[],this.firstX=null,this.firstY=null,this.lastX=null,this.lastY=null,this.lastCommand=null}addShape(t){this.shapes.push(t)}arcAbs(t,e,n,s,i,a,o){if(0===t||0===e)this.addShape(this.shapeCreator.line(this.lastX,this.lastY,a,o));else{const c=Y(new r(this.lastX,this.lastY),new r(a,o),t,e,n,s,i);this.addShape(this.shapeCreator.arc(...c))}this.lastCommand="A",this.lastX=a,this.lastY=o}arcRel(t,e,n,s,i,a,o){if(0===t||0===e)this.addShape(this.shapeCreator.line(this.lastX,this.lastY,this.lastX+a,this.lastY+o));else{const c=Y(new r(this.lastX,this.lastY),new r(this.lastX+a,this.lastY+o),t,e,n,s,i);this.addShape(this.shapeCreator.arc(...c))}this.lastCommand="a",this.lastX+=a,this.lastY+=o}curvetoCubicAbs(t,e,n,s,r,i){this.addShape(this.shapeCreator.cubicBezier(this.lastX,this.lastY,t,e,n,s,r,i)),this.lastX=r,this.lastY=i,this.lastCommand="C"}curvetoCubicRel(t,e,n,s,r,i){this.addShape(this.shapeCreator.cubicBezier(this.lastX,this.lastY,this.lastX+t,this.lastY+e,this.lastX+n,this.lastY+s,this.lastX+r,this.lastY+i)),this.lastX+=r,this.lastY+=i,this.lastCommand="c"}linetoHorizontalAbs(t){this.addShape(this.shapeCreator.line(this.lastX,this.lastY,t,this.lastY)),this.lastX=t,this.lastCommand="H"}linetoHorizontalRel(t){this.addShape(this.shapeCreator.line(this.lastX,this.lastY,this.lastX+t,this.lastY)),this.lastX+=t,this.lastCommand="h"}linetoAbs(t,e){this.addShape(this.shapeCreator.line(this.lastX,this.lastY,t,e)),this.lastX=t,this.lastY=e,this.lastCommand="L"}linetoRel(t,e){this.addShape(this.shapeCreator.line(this.lastX,this.lastY,this.lastX+t,this.lastY+e)),this.lastX+=t,this.lastY+=e,this.lastCommand="l"}movetoAbs(t,e){this.firstX=t,this.firstY=e,this.lastX=t,this.lastY=e,this.lastCommand="M"}movetoRel(t,e){this.firstX+=t,this.firstY+=e,this.lastX+=t,this.lastY+=e,this.lastCommand="m"}curvetoQuadraticAbs(t,e,n,s){this.addShape(this.shapeCreator.quadraticBezier(this.lastX,this.lastY,t,e,n,s)),this.lastX=n,this.lastY=s,this.lastCommand="Q"}curvetoQuadraticRel(t,e,n,s){this.addShape(this.shapeCreator.quadraticBezier(this.lastX,this.lastY,this.lastX+t,this.lastY+e,this.lastX+n,this.lastY+s)),this.lastX+=n,this.lastY+=s,this.lastCommand="q"}curvetoCubicSmoothAbs(t,e,n,s){let r,i;if(this.lastCommand.match(/^[SsCc]$/)){const t=this.shapes[this.shapes.length-1].args[2];r=2*this.lastX-t.x,i=2*this.lastY-t.y}else r=this.lastX,i=this.lastY;this.addShape(this.shapeCreator.cubicBezier(this.lastX,this.lastY,r,i,t,e,n,s)),this.lastX=n,this.lastY=s,this.lastCommand="S"}curvetoCubicSmoothRel(t,e,n,s){let r,i;if(this.lastCommand.match(/^[SsCc]$/)){const t=this.shapes[this.shapes.length-1].args[2];r=2*this.lastX-t.x,i=2*this.lastY-t.y}else r=this.lastX,i=this.lastY;this.addShape(this.shapeCreator.cubicBezier(this.lastX,this.lastY,r,i,this.lastX+t,this.lastY+e,this.lastX+n,this.lastY+s)),this.lastX+=n,this.lastY+=s,this.lastCommand="s"}curvetoQuadraticSmoothAbs(t,e){let n,s;if(this.lastCommand.match(/^[QqTt]$/)){const t=this.shapes[this.shapes.length-1].args[1];n=2*this.lastX-t.x,s=2*this.lastY-t.y}else n=this.lastX,s=this.lastY;this.addShape(this.shapeCreator.quadraticBezier(this.lastX,this.lastY,n,s,t,e)),this.lastX=t,this.lastY=e,this.lastCommand="T"}curvetoQuadraticSmoothRel(t,e){let n,s;if(this.lastCommand.match(/^[QqTt]$/)){const t=this.shapes[this.shapes.length-1].args[1];n=2*this.lastX-t.x,s=2*this.lastY-t.y}else n=this.lastX,s=this.lastY;this.addShape(this.shapeCreator.quadraticBezier(this.lastX,this.lastY,n,s,this.lastX+t,this.lastY+e)),this.lastX+=t,this.lastY+=e,this.lastCommand="t"}linetoVerticalAbs(t){this.addShape(this.shapeCreator.line(this.lastX,this.lastY,this.lastX,t)),this.lastY=t,this.lastCommand="V"}linetoVerticalRel(t){this.addShape(this.shapeCreator.line(this.lastX,this.lastY,this.lastX,this.lastY+t)),this.lastY+=t,this.lastCommand="v"}closePath(){this.addShape(this.shapeCreator.line(this.lastX,this.lastY,this.firstX,this.firstY)),this.lastX=this.firstX,this.lastY=this.firstY,this.lastCommand="z"}};const L=.5*Math.PI;class O{constructor(t,e){this.name=t,this.args=e}static arc(...t){return S(O.ARC,t,["center","radiusX","radiusY","startRadians","endRadians"])}static quadraticBezier(...t){return S(O.QUADRATIC_BEZIER,t,["p1","p2","p3"])}static cubicBezier(...t){return S(O.CUBIC_BEZIER,t,["p1","p2","p3","p4"])}static circle(...t){return S(O.CIRCLE,t,["center","radius"])}static ellipse(...t){return S(O.ELLIPSE,t,["center","radiusX","radiusY"])}static line(...t){return S(O.LINE,t,["p1","p2"])}static path(...t){return S(O.PATH,t,["segments"])}static polygon(...t){return S(O.POLYGON,t,["points"])}static polyline(...t){return S(O.POLYLINE,t,["points"])}static rectangle(...t){const e=S(O.RECTANGLE,t,["topLeft","bottomRight","rx","ry"]);let n=e.args.pop(),s=e.args.pop();if(n=void 0===n?0:n,0===(s=void 0===s?0:s)&&0===n)return e;const{x:r,y:i}=e.args[0],{x:a,y:o}=e.args[1],c=a-r,h=o-i;0===s&&(s=n),0===n&&(n=s),s>.5*c&&(s=.5*c),n>.5*h&&(n=.5*h);const u=r,l=i,y=r+s,p=i+n,x=a-s,d=o-n,m=a,f=o,b=[O.arc(y,p,s,n,2*L,3*L),O.line(y,l,x,l),O.arc(x,p,s,n,3*L,4*L),O.line(m,p,m,d),O.arc(x,d,s,n,0,L),O.line(x,f,y,f),O.arc(y,d,s,n,L,2*L),O.line(u,d,u,p)];return new O(O.PATH,b)}}function S(t,e,n){let s;1===e.length?(e=e[0],s=Array.isArray(e)||"string"===typeof e?t+"Args":t):s=t+"Args";const r=j.execute(s,e);if(r===k)throw new TypeError(`${t} is not in a recognizable format: ${JSON.stringify(e)}`);const i=1===n.length?r[n[0]]:n.map(t=>r[t]);return new O(t,i)}O.ARC="Arc",O.QUADRATIC_BEZIER="Bezier2",O.CUBIC_BEZIER="Bezier3",O.CIRCLE="Circle",O.ELLIPSE="Ellipse",O.LINE="Line",O.PATH="Path",O.POLYGON="Polygon",O.POLYLINE="Polyline",O.RECTANGLE="Rectangle";const j=new class{constructor(){this.symbolTable={},this.functions={},this.messages=[],this.verbose=!1;for(const t in s)this.functions[t]=s[t]}addFunction(t,e){this.functions[t]=e}addInfo(t){this.verbose&&this.messages.push({type:"message",level:"info",message:t})}addWarning(t){this.messages.push({type:"message",level:"warning",message:t})}addError(t){this.messages.push({type:"message",level:"error",message:t})}execute(t,e){const n=l.parse(t);let s;this.messages=[];for(const r of n)switch(r.type){case"assignment":case"def":case"sequence":s=this.executeExpression(r,e,this.symbolTable);break;default:return this.addError(`unknown statement type: ${r.type}`),k}return s}executeExpression(t,e,n){const s=s=>{const r=this.executeExpression(t.left,e,n);if(r!==k&&"number"===typeof r){const i=this.executeExpression(t.right,e,n);if(i!==k&&"number"===typeof i)return s(r,i)}return k};switch(t.type){case"assignment":{const s=this.executeExpression(t.value,e,n);return s===k?(this.addError(`Unable to evaluate assignment value for ${t.name}`),k):(n[t.name]=s,s)}case"def":return void(n[t.name]=t.value);case"get-value":if(t.name in n){const s=n[t.name];if(A(s)&&"sequence"===s.type){const r=this.executeExpression(s,e,n);return r===k?(this.addError(`Unable to evaluate sequence ${t.name}`),k):r}return s}return t.name in this.functions?this.invokeFunction(t.name,[e]):(this.addError(`Tried to access unbound symbol: ${t.name}`),k);case"get-property":{const s=this.executeExpression(t.left,e,n);return A(s)?s[t.right]:k}case"get-index":{const{left:s,right:r}=t,i=this.executeExpression(s,e,n);if(Array.isArray(i)){const t=r<0?i.length+r:r;return 0<=t&&t<i.length?i[t]:k}return k}case"get-structure":return e;case"sequences":{let s=k;for(const r of t.sequences){const t=Object.create(n);if((s=this.executeExpression(r,e,t))!==k){Object.assign(n,t);break}}return s}case"sequence":{let s=e;for(const e of t.steps)if((s="pattern"===e.type?this.executePattern(e,s,n):this.executeExpression(e,s,n))===k)return k;return s}case"add":return s((t,e)=>t+e);case"map":{const[s,r]=t.value,i=this.executeExpression(s,e,n);if(i!==k){if(!1===Array.isArray(i))return this.addError("First argument of map must evaluate to an array"),k;const t=Object.create(n);return i.map(e=>this.executeExpression(r,e,t))}return k}case"patterns":{let s=k;for(const r of t.patterns){const t=Object.create(n);if((s=this.executePattern(r,e,t))!==k){Object.assign(n,t);break}}return s}case"subtract":return s((t,e)=>t-e);case"multiply":return s((t,e)=>t*e);case"divide":return s((t,e)=>t/e);case"invoke":{const s=t.args.reduce((t,s)=>{if("spread"===s.type){const r=this.executeExpression(s.expression,e,n);Array.isArray(r)?t=t.concat(r):t.push(r)}else t.push(this.executeExpression(s,e,n));return t},[]);return t.name in this.functions?this.invokeFunction(t.name,s):(this.addError(`Tried to access unbound symbol: ${t.name}`),k)}case"array":{const s=[];for(const r of t.value)if("assignment"===r.type)this.executeExpression(r,e,n);else{const t=this.executeExpression(r,e,n);if(t===k)return k;s.push(t)}return s}case"boolean":case"null":case"number":case"string":case"undefined":return t.value;case"object":return this.executeObjectExpression(t,e,n);default:return this.addError(`Unrecognized expression type: '${t.type}'`),k}}executeObjectExpression(t,e,n){const s=Object.create(n),r={};for(const i of t.value)switch(i.type){case"property":{const t=this.executeExpression(i.name,e,s);if(t===k)return k;if("string"!==typeof t)return this.addError(`Property names must be string types: ${t}`),k;const a=null!==i.value?this.executeExpression(i.value,e,s):n[t];if(a===k)return this.addError(`Unable to evaluate value for property ${t}`),k;r[t]=a;break}case"assignment":if(this.executeExpression(i,e,s)===k)return k;break;default:return this.addError(`Unrecognized object expression element type: ${i.type}`),k}return r}executePattern(t,e,n){switch(t.patternType){case"any":return this.assign(n,t.assignTo,e),e;case"array":return Array.isArray(e)?(this.assign(n,t.assignTo,e),e):k;case"array-pattern":return this.executeArrayPattern(t,e,n)===k?k:n;case"boolean":return"boolean"!==typeof e||null!==t.value&&t.value!==e?k:(this.assign(n,t.assignTo,e),e);case"null":return null===e?(this.assign(n,t.assignTo,e),e):k;case"number":return"number"!==typeof e||null!==t.value&&t.value!==e?k:(this.assign(n,t.assignTo,e),e);case"object":return A(e)?(this.assign(n,t.assignTo,e),e):k;case"object-pattern":{if(!1===A(e))return k;const s={};for(const r of t.value){const{name:t,pattern:i,assignTo:a}=r;if(!(t in e))return k;{const r=this.executePattern(i,e[t],n);if(r===k)return k;this.assign(n,a,e[t]),this.assign(s,a,r)}}return this.assign(n,t.assignTo,e),s}case"reference":if(t.value in this.patterns){const s=this.patterns[t.value],r=this.executePattern(s,e,n);return r!==k&&this.assign(n,t.assignTo,r),r}return k;case"string":return"string"!==typeof e||null!==t.value&&t.value!==e?k:(this.assign(n,t.assignTo,e),e);case"undefined":return void 0===e?(this.assign(n,t.assignTo,e),e):k;default:throw new TypeError(`unrecognized pattern type: '${t.type}'`)}}executeArrayPattern(t,e,n){if(!1===Array.isArray(e))return k;let s=[],r=0;for(const i of t.value){const t=this.executeArrayPatternElement(i,r,e,n);if(t===k)return k;s=s.concat(t),r+=t.length}return r===e.length?(this.assign(n,t.assignTo,e),s):k}executeArrayPatternElement(t,e,n,s){let r=[];switch(t.type){case"element":{const i=this.executeArrayElementPattern(t,e,n,s);if(i===k)return k;r=r.concat(i),e+=i.length;break}case"element-group":{const i=this.executeArrayElementGroupPattern(t,e,n,s);if(i===k)return k;r=r.concat(i),e+=i.length;break}default:return this.addError(`Unrecognized array pattern element type: '${t.type}'`),k}return r}executeArrayElementPattern(t,e,n,s){const{pattern:r,range:{start:i,stop:a}}=t,o=[];for(let c=0;c<a;c++){const h=e+c,u=h<n.length?this.executePattern(r,n[h],s):k;if(u===k){if(c>=i)break;return k}a>1?this.pushAssign(s,t.assignTo,u):this.assign(s,t.assignTo,u),o.push(u)}return o}executeArrayElementGroupPattern(t,e,n,s){const{elements:r,range:{start:i,stop:a}}=t;let o=[];for(let c=0;c<a;c++){let h=[];for(const t of r){const r=Object.create(s),i=this.executeArrayPatternElement(t,e,n,r);if(i===k){h=k;break}null!==t.assignTo&&void 0!==t.assignTo&&t.assignTo in r&&(a>1?this.pushAssign(s,t.assignTo,r[t.assignTo]):this.assign(s,t.assignTo,r[t.assignTo])),o=o.concat(i),e+=i.length,h=h.concat(i)}if(h===k){if(c>=i){if(0===c){this.assign(s,t.assignTo,[]);for(const t of r)this.assign(s,t.assignTo,[])}return o}return k}a>1?this.pushAssign(s,t.assignTo,h):this.assign(s,t.assignTo,h)}return o}invokeFunction(t,e){return t in this.functions?this.functions[t](...e):k}assign(t,e,n){null!==e&&void 0!==e&&(t.hasOwnProperty(e)&&this.addWarning(`Overwriting ${e} with value: ${n}`),t[e]=n)}pushAssign(t,e,n){if(null!==e&&void 0!==e){const s=t.hasOwnProperty(e)?t[e]:[];Array.isArray(s)?(s.push(n),t[e]=s):this.addWarning(`Unable to push to ${e} because it is not an array: ${s}`)}}};j.execute('\ndef Center =\n    patterns {\n        { center: { x: number as x, y: number as y } },\n        { center: [ number as x, number as y ] },\n        { cx: number as x, cy: number as y },\n        { centerX: number as x, centerY: number as y }\n    } |> Point2D(x, y);\n\ndef Radii =\n    patterns {\n        { radii: { x: number as rx, y: number as ry } },\n        { radii: [ number as rx, number as ry ] },\n        { rx: number as rx, ry: number as ry },\n        { radiusX: number as rx, radiusY: number as ry }\n    } |> { "rx", "ry" };\n\ndef P1 =\n    patterns {\n        { p1: { x: number as x, y: number as y } },\n        { p1: [ number as x, number as y ] },\n        { p1x: number as x, p1y: number as y }\n    } |> Point2D(x, y);\n        \ndef P2 =\n    patterns {\n        { p1: { x: number as x, y: number as y } },\n        { p1: [ number as x, number as y ] },\n        { p1x: number as x, p1y: number as y }\n    } |> Point2D(x, y);\n        \ndef P3 =\n    patterns {\n        { p1: { x: number as x, y: number as y } },\n        { p1: [ number as x, number as y ] },\n        { p1x: number as x, p1y: number as y }\n    } |> Point2D(x, y);\n        \ndef P4 =\n    patterns {\n        { p1: { x: number as x, y: number as y } },\n        { p1: [ number as x, number as y ] },\n        { p1x: number as x, p1y: number as y }\n    } |> Point2D(x, y);\n\n            \ndef Arc = {\n    let radii = Radii,\n\n    "center": Center,\n    "radiusX": radii.rx,\n    "radiusY": radii.ry,\n    "startRadians": =~ number,\n    "endRadians": =~ number\n};\n\ndef ArcArgs = {\n    let elements =\n        patterns {\n            [ number as centerX, number as centerY, number as radiusX, number as radiusY, number as startRadians, number as endRadians ],\n            [ { x: number as centerX, y: number as centerY }, number as radiusX, number as radiusY, number as startRadians, number as endRadians ]\n        } |> { "centerX", "centerY", "radiusX", "radiusY", "startRadians", "endRadians" },\n    \n    "center": Point2D(elements.centerX, elements.centerY),\n    "radiusX": elements.radiusX,\n    "radiusY": elements.radiusY,\n    "startRadians": elements.startRadians,\n    "endRadians": elements.endRadians\n};\n\ndef Bezier2 = {\n    "p1": P1,\n    "p2": P2,\n    "p3": P3\n};\n\ndef Bezier2Args = {\n    let elements =\n        patterns {\n            [ number as p1x, number as p1y, number as p2x, number as p2y, number as p3x, number as p3y ],\n            [ { x: number as p1x, y: number as p1y }, { x: number as p2x, y: number as p2y }, { x: number as p3x, y: number as p3y }]\n        } |> { "p1x", "p1y", "p2x", "p2y", "p3x", "p3y" },\n    \n    "p1": Point2D(elements.p1x, elements.p1y),\n    "p2": Point2D(elements.p2x, elements.p2y),\n    "p3": Point2D(elements.p3x, elements.p3y)\n};\n\ndef Bezier3 = {\n    "p1": P1,\n    "p2": P2,\n    "p3": P3,\n    "p4": P4\n};\n\ndef Bezier3Args = {\n    let elements =\n        patterns {\n            [ number as p1x, number as p1y, number as p2x, number as p2y, number as p3x, number as p3y, number as p4x, number as p4y ],\n            [ { x: number as p1x, y: number as p1y }, { x: number as p2x, y: number as p2y }, { x: number as p3x, y: number as p3y }, { x: number as p4x, y: number as p4y }]\n        } |> { "p1x", "p1y", "p2x", "p2y", "p3x", "p3y", "p4x", "p4y" },\n    \n    "p1": Point2D(elements.p1x, elements.p1y),\n    "p2": Point2D(elements.p2x, elements.p2y),\n    "p3": Point2D(elements.p3x, elements.p3y),\n    "p4": Point2D(elements.p4x, elements.p4y)\n};\n\ndef Circle = {\n    "center": Center,\n    "radius":\n        patterns {\n            { r: number as radius},\n            { radius: number as radius }\n        } |> radius\n};\n\ndef CircleArgs = {\n    let elements =\n        patterns {\n            [ number as centerX, number as centerY, number as radius ],\n            [ { x: number as centerX, y: number as centerY }, number as radius ]\n        } |> { "centerX", "centerY", "radius" },\n    \n    "center": Point2D(elements.centerX, elements.centerY),\n    "radius": elements.radius\n};\n\ndef Ellipse = {\n    let radii = Radii,\n\n    "center": Center,\n    "radiusX": radii.rx,\n    "radiusY": radii.ry\n};\n\ndef EllipseArgs = {\n    let elements =\n       patterns {\n            [ number as centerX, number as centerY, number as radiusX, number as radiusY ],\n            [ { x: number as centerX, y: number as centerY }, number as radiusX, number as radiusY ]\n        } |> { "centerX", "centerY", "radiusX", "radiusY" },\n    \n    "center": Point2D(elements.centerX, elements.centerY),\n    "radiusX": elements.radiusX,\n    "radiusY": elements.radiusY\n};\n\ndef Line = {\n    "p1": P1,\n    "p2": P2\n};\n\ndef LineArgs = {\n    let elements =\n        patterns {\n            [ number as p1x, number as p1y, number as p2x, number as p2y ],\n            [ { x: number as p1x, y: number as p1y }, { x: number as p2x, y: number as p2y } ]\n        } |> { "p1x", "p1y", "p2x", "p2y" },\n        \n    "p1": Point2D(elements.p1x, elements.p1y),\n    "p2": Point2D(elements.p2x, elements.p2y)\n};\n\ndef Path = {\n    "segments":\n        =~ { d: string as data } |> PathData(data)\n};\n\ndef PathArgs = {\n    "segments":\n        =~ string as data |> PathData(data)\n};\n\ndef Polygon = {\n    "points":\n        sequences {\n            =~ { points: [ (number, number); 0.. as coords ] }\n            |> [ map(coords, Point2D(...$)) ],\n\n            =~ { points: [ { x: number, y: number }; 0.. ] as points }\n            |> [ map(points, Point2D($.x, $.y)) ]\n        }\n};\n\ndef PolygonArgs = {\n    "points":\n        sequences {\n            =~ [ (number, number); 0.. as coords ]\n            |> [ map(coords, Point2D(...$)) ],\n\n            =~ [ { x: number, y: number }; 0.. ] as points\n            |> [ map(points, Point2D($.x, $.y)) ]\n        }\n};\n\ndef Polyline = {\n    "points":\n        sequences {\n            =~ { points: [ (number, number); 0.. as coords ] }\n            |> [ map(coords, Point2D(...$)) ],\n\n            =~ { points: [ { x: number, y: number }; 0.. ] as points }\n            |> [ map(points, Point2D($.x, $.y)) ]\n        }\n};\n\ndef PolylineArgs = {\n    "points":\n        sequences {\n            =~ [ (number, number); 0.. as coords ]\n            |> [ map(coords, Point2D(...$)) ],\n\n            =~ [ { x: number, y: number }; 0.. ] as points\n            |> [ map(points, Point2D($.x, $.y)) ]\n        }\n};\n\ndef Rectangle = {\n    let topLeft =\n        patterns {\n            { topLeft: { x: number as x, y: number as y } },\n            { topLeft: [ number as x, number as y ] },\n            { x: number as x, y: number as y },\n            { top: number as x, left: number as y }\n        } |> { "x", "y" },\n\n    "topLeft":\n        Point2D(topLeft.x, topLeft.y),\n\n    "bottomRight":\n        sequences {\n            patterns {\n                { bottomRight: { x: number as x, y: number as y } },\n                { bottomRight: [ number as x, number as y ] }\n            } |> Point2D(x, y),\n            patterns {\n                { w: number as w, h: number as h },\n                { width: number as w, height: number as h },\n                { size: { x: number as w, y: number as h } },\n                { size: [ number as w, number as h ] }\n            } |> Point2D(topLeft.x + w, topLeft.y + h)\n        },\n\n    "rx":\n        sequences {\n            =~ { rx: number as rx } |> rx,\n            =~ any |> 0\n        },\n    "ry":\n        sequences {\n            =~ { ry: number as ry } |> ry,\n            =~ any |> 0\n        }\n};\n\ndef RectangleArgs = {\n    let elements =\n        patterns {\n            [ number as x, number as y, number as width, number as height ],\n            [ number as x, number as y, number as width, number as height, number as rx, number as ry ],\n            [ { x: number as x, y: number as y }, { x: number as width, y: number as height } ],\n            [ { x: number as x, y: number as y }, { x: number as width, y: number as height }, { rx: number as rx, ry: number as ry } ],\n            [ { x: number as x, y: number as y }, { x: number as width, y: number as height }, { radiusX: number as rx, radiusY: number as ry } ]\n        } |> { "x", "y", "width", "height", "rx", "ry" },\n\n    "topLeft": Point2D(elements.x, elements.y),\n    "bottomRight": Point2D(elements.x + elements.width, elements.y + elements.height),\n    "rx": elements.rx,\n    "ry": elements.ry\n}\n'),j.addFunction("Point2D",(t,e)=>new r(t,e)),j.addFunction("PathData",t=>{const e=new $,n=new C(O);return e.setHandler(n),e.parseData(t),n.shapes});const D=2*Math.PI,B=new a(1,0);function z(t){return null===t||void 0===t}function q(t){const e=t%D;return e<0?e+D:e}function U(t){const e=t.slice();return e.push(t[0]),e}class F{constructor(t){this.init(t)}init(t){this.status=t,this.points=[]}static intersect(t,e){let n;if(z(t)||z(e))n=new F("No Intersection");else if("Path"===t.name)n=F.intersectPathShape(t,e);else if("Path"===e.name)n=F.intersectPathShape(e,t);else if("Arc"===t.name)n=F.intersectArcShape(t,e);else if("Arc"===e.name)n=F.intersectArcShape(e,t);else{let s,r;if(t.name<e.name?(s="intersect"+t.name+e.name,r=t.args.concat(e.args)):(s="intersect"+e.name+t.name,r=e.args.concat(t.args)),!(s in F))throw new TypeError("Intersection not available: "+s);n=F[s].apply(null,r)}return n}static intersectPathShape(t,e){const n=new F("No Intersection");for(const s of t.args){const t=F.intersect(s,e);n.appendPoints(t.points)}return n.points.length>0&&(n.status="Intersection"),n}static intersectArcShape(t,e){const[n,s,r,i,o]=t.args,c=new O(O.ELLIPSE,[n,s,r]);return function(t,e,n,s,r,i){if(0===t.points.length)return t;const o=new F("No Intersection"),c=q(r);let h=q(i);h<c&&(h+=D);for(const u of t.points){const t=q(B.angleBetween(a.fromPoints(e,u)));c<=t&&t<=h&&o.appendPoint(u)}return o.points.length>0&&(o.status="Intersection"),o}(F.intersect(c,e),n,0,0,i,o)}static intersectBezier2Bezier2(t,e,n,s,i,a){let o,c;const h=new F("No Intersection");o=e.multiply(-2);const l=t.add(o.add(n));o=t.multiply(-2),c=e.multiply(2);const y=o.add(c),p=new r(t.x,t.y);o=i.multiply(-2);const x=s.add(o.add(a));o=s.multiply(-2),c=i.multiply(2);const d=o.add(c),m=new r(s.x,s.y);o=l.x*y.y-y.x*l.y,c=x.x*y.y-y.x*x.y;const f=d.x*y.y-y.x*d.y,b=y.x*(p.y-m.y)+y.y*(-p.x+m.x),g=x.x*l.y-l.x*x.y,w=d.x*l.y-l.x*d.y,v=l.x*(p.y-m.y)+l.y*(-p.x+m.x),P=new u(-g*g,-2*g*w,o*c-w*w-2*g*v,o*f-2*w*v,o*b-v*v).getRoots();for(const r of P)if(0<=r&&r<=1){const t=new u(l.x,y.x,p.x-m.x-r*d.x-r*r*x.x);t.simplifyEquals();const e=t.getRoots(),n=new u(l.y,y.y,p.y-m.y-r*d.y-r*r*x.y);n.simplifyEquals();const s=n.getRoots();if(e.length>0&&s.length>0){const t=1e-4;t:for(const n of e)if(0<=n&&n<=1)for(let e=0;e<s.length;e++)if(Math.abs(n-s[e])<t){h.points.push(x.multiply(r*r).add(d.multiply(r).add(m)));break t}}}return h.points.length>0&&(h.status="Intersection"),h}static intersectBezier2Bezier3(t,e,n,s,i,a,o){let c,h,l,y;const p=new F("No Intersection");c=e.multiply(-2);const x=t.add(c.add(n));c=t.multiply(-2),h=e.multiply(2);const d=c.add(h),m=new r(t.x,t.y);c=s.multiply(-1),h=i.multiply(3),l=a.multiply(-3),y=c.add(h.add(l.add(o)));const f=new r(y.x,y.y);c=s.multiply(3),h=i.multiply(-6),l=a.multiply(3),y=c.add(h.add(l));const b=new r(y.x,y.y);c=s.multiply(-3),h=i.multiply(3),l=c.add(h);const g=new r(l.x,l.y),w=new r(s.x,s.y),v=m.x*m.x,P=m.y*m.y,E=d.x*d.x,M=d.y*d.y,k=x.x*x.x,A=x.y*x.y,R=w.x*w.x,T=w.y*w.y,I=g.x*g.x,_=g.y*g.y,X=b.x*b.x,$=b.y*b.y,N=f.x*f.x,Y=f.y*f.y,C=new u(-2*x.x*x.y*f.x*f.y+k*Y+A*N,-2*x.x*x.y*b.x*f.y-2*x.x*x.y*b.y*f.x+2*A*b.x*f.x+2*k*b.y*f.y,-2*x.x*g.x*x.y*f.y-2*x.x*x.y*g.y*f.x-2*x.x*x.y*b.x*b.y+2*g.x*A*f.x+A*X+k*(2*g.y*f.y+$),2*m.x*x.x*x.y*f.y+2*m.y*x.x*x.y*f.x+d.x*d.y*x.x*f.y+d.x*d.y*x.y*f.x-2*w.x*x.x*x.y*f.y-2*x.x*w.y*x.y*f.x-2*x.x*g.x*x.y*b.y-2*x.x*x.y*g.y*b.x-2*m.x*A*f.x-2*m.y*k*f.y+2*w.x*A*f.x+2*g.x*A*b.x-M*x.x*f.x-E*x.y*f.y+k*(2*w.y*f.y+2*g.y*b.y),2*m.x*x.x*x.y*b.y+2*m.y*x.x*x.y*b.x+d.x*d.y*x.x*b.y+d.x*d.y*x.y*b.x-2*w.x*x.x*x.y*b.y-2*x.x*w.y*x.y*b.x-2*x.x*g.x*x.y*g.y-2*m.x*A*b.x-2*m.y*k*b.y+2*w.x*A*b.x-M*x.x*b.x-E*x.y*b.y+I*A+k*(2*w.y*b.y+_),2*m.x*x.x*x.y*g.y+2*m.y*x.x*g.x*x.y+d.x*d.y*x.x*g.y+d.x*d.y*g.x*x.y-2*w.x*x.x*x.y*g.y-2*x.x*w.y*g.x*x.y-2*m.x*g.x*A-2*m.y*k*g.y+2*w.x*g.x*A-M*x.x*g.x-E*x.y*g.y+2*k*w.y*g.y,-2*m.x*m.y*x.x*x.y-m.x*d.x*d.y*x.y-m.y*d.x*d.y*x.x+2*m.x*x.x*w.y*x.y+2*m.y*w.x*x.x*x.y+d.x*w.x*d.y*x.y+d.x*d.y*x.x*w.y-2*w.x*x.x*w.y*x.y-2*m.x*w.x*A+m.x*M*x.x+m.y*E*x.y-2*m.y*k*w.y-w.x*M*x.x-E*w.y*x.y+v*A+P*k+R*A+k*T).getRootsInInterval(0,1);for(const r of C){const t=new u(x.x,d.x,m.x-w.x-r*g.x-r*r*b.x-r*r*r*f.x).getRoots(),e=new u(x.y,d.y,m.y-w.y-r*g.y-r*r*b.y-r*r*r*f.y).getRoots();if(t.length>0&&e.length>0){const n=1e-4;t:for(const s of t)if(0<=s&&s<=1)for(let t=0;t<e.length;t++)if(Math.abs(s-e[t])<n){p.points.push(f.multiply(r*r*r).add(b.multiply(r*r).add(g.multiply(r).add(w))));break t}}}return p.points.length>0&&(p.status="Intersection"),p}static intersectBezier2Circle(t,e,n,s,r){return F.intersectBezier2Ellipse(t,e,n,s,r,r)}static intersectBezier2Ellipse(t,e,n,s,i,a){let o;const c=new F("No Intersection");o=e.multiply(-2);const h=t.add(o.add(n));o=t.multiply(-2);const l=e.multiply(2),y=o.add(l),p=new r(t.x,t.y),x=i*i,d=a*a,m=new u(d*h.x*h.x+x*h.y*h.y,2*(d*h.x*y.x+x*h.y*y.y),d*(2*h.x*p.x+y.x*y.x)+x*(2*h.y*p.y+y.y*y.y)-2*(d*s.x*h.x+x*s.y*h.y),2*(d*y.x*(p.x-s.x)+x*y.y*(p.y-s.y)),d*(p.x*p.x+s.x*s.x)+x*(p.y*p.y+s.y*s.y)-2*(d*s.x*p.x+x*s.y*p.y)-x*d).getRoots();for(const r of m)0<=r&&r<=1&&c.points.push(h.multiply(r*r).add(y.multiply(r).add(p)));return c.points.length>0&&(c.status="Intersection"),c}static intersectBezier2Line(t,e,n,s,i){let o;const c=s.min(i),h=s.max(i),l=new F("No Intersection");o=e.multiply(-2);const y=t.add(o.add(n));o=t.multiply(-2);const p=e.multiply(2),x=o.add(p),d=new r(t.x,t.y),m=new a(s.y-i.y,i.x-s.x),f=s.x*i.y-i.x*s.y,b=new u(m.dot(y),m.dot(x),m.dot(d)+f).getRoots();for(const r of b)if(0<=r&&r<=1){const a=t.lerp(e,r),o=e.lerp(n,r),u=a.lerp(o,r);s.x===i.x?c.y<=u.y&&u.y<=h.y&&(l.status="Intersection",l.appendPoint(u)):s.y===i.y?c.x<=u.x&&u.x<=h.x&&(l.status="Intersection",l.appendPoint(u)):c.x<=u.x&&u.x<=h.x&&c.y<=u.y&&u.y<=h.y&&(l.status="Intersection",l.appendPoint(u))}return l}static intersectBezier2Polygon(t,e,n,s){return F.intersectBezier2Polyline(t,e,n,U(s))}static intersectBezier2Polyline(t,e,n,s){const r=new F("No Intersection"),{length:i}=s;for(let a=0;a<i-1;a++){const i=s[a],o=s[a+1],c=F.intersectBezier2Line(t,e,n,i,o);r.appendPoints(c.points)}return r.points.length>0&&(r.status="Intersection"),r}static intersectBezier2Rectangle(t,e,n,s,i){const a=s.min(i),o=s.max(i),c=new r(o.x,a.y),h=new r(a.x,o.y),u=F.intersectBezier2Line(t,e,n,a,c),l=F.intersectBezier2Line(t,e,n,c,o),y=F.intersectBezier2Line(t,e,n,o,h),p=F.intersectBezier2Line(t,e,n,h,a),x=new F("No Intersection");return x.appendPoints(u.points),x.appendPoints(l.points),x.appendPoints(y.points),x.appendPoints(p.points),x.points.length>0&&(x.status="Intersection"),x}static intersectBezier3Bezier3(t,e,n,s,i,a,o,c){let h,l,y,p;const x=new F("No Intersection");h=t.multiply(-1),l=e.multiply(3),y=n.multiply(-3),p=h.add(l.add(y.add(s)));const d=new r(p.x,p.y);h=t.multiply(3),l=e.multiply(-6),y=n.multiply(3),p=h.add(l.add(y));const m=new r(p.x,p.y);h=t.multiply(-3),l=e.multiply(3),y=h.add(l);const f=new r(y.x,y.y),b=new r(t.x,t.y);h=i.multiply(-1),l=a.multiply(3),y=o.multiply(-3),p=h.add(l.add(y.add(c)));const g=new r(p.x,p.y);h=i.multiply(3),l=a.multiply(-6),y=o.multiply(3),p=h.add(l.add(y));const w=new r(p.x,p.y);h=i.multiply(-3),l=a.multiply(3),y=h.add(l);const v=new r(y.x,y.y),P=new r(i.x,i.y);h=d.x*m.y-m.x*d.y,l=d.x*f.y-f.x*d.y;const E=d.x*b.y-b.x*d.y+P.x*d.y-d.x*P.y,M=v.x*d.y-d.x*v.y,k=w.x*d.y-d.x*w.y,A=g.x*d.y-d.x*g.y;p=d.x*f.y-f.x*d.y;const R=d.x*b.y+m.x*f.y-f.x*m.y-b.x*d.y+P.x*d.y-d.x*P.y,T=v.x*d.y-d.x*v.y,I=w.x*d.y-d.x*w.y,_=g.x*d.y-d.x*g.y,X=m.x*b.y-b.x*m.y+P.x*m.y-m.x*P.y,$=v.x*m.y-m.x*v.y,N=w.x*m.y-m.x*w.y,Y=g.x*m.y-m.x*g.y,C=d.x*b.y-b.x*d.y+P.x*d.y-d.x*P.y,L=v.x*d.y-d.x*v.y,O=w.x*d.y-d.x*w.y,S=g.x*d.y-d.x*g.y,j=m.x*b.y-b.x*m.y+P.x*m.y-m.x*P.y,D=v.x*m.y-m.x*v.y,B=w.x*m.y-m.x*w.y,z=g.x*m.y-m.x*g.y,q=f.x*b.y-b.x*f.y+P.x*f.y-f.x*P.y,U=v.x*f.y-f.x*v.y,Q=w.x*f.y-f.x*w.y,G=g.x*f.y-f.x*g.y,V=new u(-A*_*S,-A*_*O-A*I*S-k*_*S,-A*_*L-A*I*O-k*_*O-A*T*S-k*I*S-M*_*S,-A*_*C-A*I*L-k*_*L-A*T*O-k*I*O-M*_*O-A*R*S-k*T*S-M*I*S-E*_*S+l*Y*S+A*p*z-h*Y*z+h*_*G,-A*I*C-k*_*C-A*T*L-k*I*L-M*_*L-A*R*O-k*T*O-M*I*O-E*_*O+l*Y*O-k*R*S-M*T*S-E*I*S+l*N*S+A*p*B-h*Y*B+k*p*z-h*N*z+h*_*Q+h*I*G,-A*T*C-k*I*C-M*_*C-A*R*L-k*T*L-M*I*L-E*_*L+l*Y*L-k*R*O-M*T*O-E*I*O+l*N*O-M*R*S-E*T*S+l*$*S+A*p*D-h*Y*D+k*p*B-h*N*B+M*p*z-h*$*z+h*_*U+h*I*Q+h*T*G,-A*R*C-k*T*C-M*I*C-E*_*C+l*Y*C-k*R*L-M*T*L-E*I*L+l*N*L-M*R*O-E*T*O+l*$*O-E*R*S+l*X*S+A*p*j-h*Y*j+k*p*D-h*N*D+M*p*B-h*$*B+E*p*z-h*X*z+h*_*q+h*I*U+h*T*Q-l*p*G+h*R*G,-k*R*C-M*T*C-E*I*C+l*N*C-M*R*L-E*T*L+l*$*L-E*R*O+l*X*O+k*p*j-h*N*j+M*p*D-h*$*D+E*p*B-h*X*B+h*I*q+h*T*U-l*p*Q+h*R*Q,-M*R*C-E*T*C+l*$*C-E*R*L+l*X*L+M*p*j-h*$*j+E*p*D-h*X*D+h*T*q-l*p*U+h*R*U,-E*R*C+l*X*C+E*p*j-h*X*j-l*p*q+h*R*q);V.simplifyEquals();const Z=V.getRootsInInterval(0,1);for(const r of Z){const t=new u(d.x,m.x,f.x,b.x-P.x-r*v.x-r*r*w.x-r*r*r*g.x);t.simplifyEquals();const e=t.getRoots(),n=new u(d.y,m.y,f.y,b.y-P.y-r*v.y-r*r*w.y-r*r*r*g.y);n.simplifyEquals();const s=n.getRoots();if(e.length>0&&s.length>0){const t=1e-4;t:for(const n of e)if(0<=n&&n<=1)for(let e=0;e<s.length;e++)if(Math.abs(n-s[e])<t){x.points.push(g.multiply(r*r*r).add(w.multiply(r*r).add(v.multiply(r).add(P))));break t}}}return x.points.length>0&&(x.status="Intersection"),x}static intersectBezier3Circle(t,e,n,s,r,i){return F.intersectBezier3Ellipse(t,e,n,s,r,i,i)}static intersectBezier3Ellipse(t,e,n,s,i,a,o){let c,h,l,y;const p=new F("No Intersection");c=t.multiply(-1),h=e.multiply(3),l=n.multiply(-3),y=c.add(h.add(l.add(s)));const x=new r(y.x,y.y);c=t.multiply(3),h=e.multiply(-6),l=n.multiply(3),y=c.add(h.add(l));const d=new r(y.x,y.y);c=t.multiply(-3),h=e.multiply(3),l=c.add(h);const m=new r(l.x,l.y),f=new r(t.x,t.y),b=a*a,g=o*o,w=new u(x.x*x.x*g+x.y*x.y*b,2*(x.x*d.x*g+x.y*d.y*b),2*(x.x*m.x*g+x.y*m.y*b)+d.x*d.x*g+d.y*d.y*b,2*x.x*g*(f.x-i.x)+2*x.y*b*(f.y-i.y)+2*(d.x*m.x*g+d.y*m.y*b),2*d.x*g*(f.x-i.x)+2*d.y*b*(f.y-i.y)+m.x*m.x*g+m.y*m.y*b,2*m.x*g*(f.x-i.x)+2*m.y*b*(f.y-i.y),f.x*f.x*g-2*f.y*i.y*b-2*f.x*i.x*g+f.y*f.y*b+i.x*i.x*g+i.y*i.y*b-b*g).getRootsInInterval(0,1);for(const r of w)p.points.push(x.multiply(r*r*r).add(d.multiply(r*r).add(m.multiply(r).add(f))));return p.points.length>0&&(p.status="Intersection"),p}static intersectBezier3Line(t,e,n,s,r,i){let o,c,h,l;const y=r.min(i),p=r.max(i),x=new F("No Intersection");o=t.multiply(-1),c=e.multiply(3),h=n.multiply(-3),l=o.add(c.add(h.add(s)));const d=new a(l.x,l.y);o=t.multiply(3),c=e.multiply(-6),h=n.multiply(3),l=o.add(c.add(h));const m=new a(l.x,l.y);o=t.multiply(-3),c=e.multiply(3),h=o.add(c);const f=new a(h.x,h.y),b=new a(t.x,t.y),g=new a(r.y-i.y,i.x-r.x),w=r.x*i.y-i.x*r.y,v=new u(g.dot(d),g.dot(m),g.dot(f),g.dot(b)+w).getRoots();for(const a of v)if(0<=a&&a<=1){const o=t.lerp(e,a),c=e.lerp(n,a),h=n.lerp(s,a),u=o.lerp(c,a),l=c.lerp(h,a),d=u.lerp(l,a);r.x===i.x?y.y<=d.y&&d.y<=p.y&&(x.status="Intersection",x.appendPoint(d)):r.y===i.y?y.x<=d.x&&d.x<=p.x&&(x.status="Intersection",x.appendPoint(d)):y.x<=d.x&&d.x<=p.x&&y.y<=d.y&&d.y<=p.y&&(x.status="Intersection",x.appendPoint(d))}return x}static intersectBezier3Polygon(t,e,n,s,r){return F.intersectBezier3Polyline(t,e,n,s,U(r))}static intersectBezier3Polyline(t,e,n,s,r){const i=new F("No Intersection"),{length:a}=r;for(let o=0;o<a-1;o++){const a=r[o],c=r[o+1],h=F.intersectBezier3Line(t,e,n,s,a,c);i.appendPoints(h.points)}return i.points.length>0&&(i.status="Intersection"),i}static intersectBezier3Rectangle(t,e,n,s,i,a){const o=i.min(a),c=i.max(a),h=new r(c.x,o.y),u=new r(o.x,c.y),l=F.intersectBezier3Line(t,e,n,s,o,h),y=F.intersectBezier3Line(t,e,n,s,h,c),p=F.intersectBezier3Line(t,e,n,s,c,u),x=F.intersectBezier3Line(t,e,n,s,u,o),d=new F("No Intersection");return d.appendPoints(l.points),d.appendPoints(y.points),d.appendPoints(p.points),d.appendPoints(x.points),d.points.length>0&&(d.status="Intersection"),d}static intersectCircleCircle(t,e,n,s){let i;const a=e+s,o=Math.abs(e-s),c=t.distanceFrom(n);if(c>a)i=new F("Outside");else if(c<o)i=new F("Inside");else{i=new F("Intersection");const a=(e*e-s*s+c*c)/(2*c),o=Math.sqrt(e*e-a*a),h=t.lerp(n,a/c),u=o/c;i.points.push(new r(h.x-u*(n.y-t.y),h.y+u*(n.x-t.x))),i.points.push(new r(h.x+u*(n.y-t.y),h.y-u*(n.x-t.x)))}return i}static intersectCircleEllipse(t,e,n,s,r){return F.intersectEllipseEllipse(t,e,e,n,s,r)}static intersectCircleLine(t,e,n,s){let r;const i=(s.x-n.x)*(s.x-n.x)+(s.y-n.y)*(s.y-n.y),a=2*((s.x-n.x)*(n.x-t.x)+(s.y-n.y)*(n.y-t.y)),o=a*a-4*i*(t.x*t.x+t.y*t.y+n.x*n.x+n.y*n.y-2*(t.x*n.x+t.y*n.y)-e*e);if(o<0)r=new F("Outside");else if(0===o)r=new F("Tangent");else{const t=Math.sqrt(o),e=(-a+t)/(2*i),c=(-a-t)/(2*i);(e<0||e>1)&&(c<0||c>1)?r=new F(e<0&&c<0||e>1&&c>1?"Outside":"Inside"):(r=new F("Intersection"),0<=e&&e<=1&&r.points.push(n.lerp(s,e)),0<=c&&c<=1&&r.points.push(n.lerp(s,c)))}return r}static intersectCirclePolygon(t,e,n){return F.intersectCirclePolyline(t,e,U(n))}static intersectCirclePolyline(t,e,n){const s=new F("No Intersection"),{length:r}=n;let i;for(let a=0;a<r-1;a++){const r=n[a],o=n[a+1];i=F.intersectCircleLine(t,e,r,o),s.appendPoints(i.points)}return s.points.length>0?s.status="Intersection":s.status=i.status,s}static intersectCircleRectangle(t,e,n,s){const i=n.min(s),a=n.max(s),o=new r(a.x,i.y),c=new r(i.x,a.y),h=F.intersectCircleLine(t,e,i,o),u=F.intersectCircleLine(t,e,o,a),l=F.intersectCircleLine(t,e,a,c),y=F.intersectCircleLine(t,e,c,i),p=new F("No Intersection");return p.appendPoints(h.points),p.appendPoints(u.points),p.appendPoints(l.points),p.appendPoints(y.points),p.points.length>0?p.status="Intersection":p.status=h.status,p}static intersectEllipseEllipse(t,e,n,s,i,a){const o=[n*n,0,e*e,-2*n*n*t.x,-2*e*e*t.y,n*n*t.x*t.x+e*e*t.y*t.y-e*e*n*n],c=[a*a,0,i*i,-2*a*a*s.x,-2*i*i*s.y,a*a*s.x*s.x+i*i*s.y*s.y-i*i*a*a],h=function(t,e){const n=t[0]*e[1]-e[0]*t[1],s=t[0]*e[2]-e[0]*t[2],r=t[0]*e[3]-e[0]*t[3],i=t[0]*e[4]-e[0]*t[4],a=t[0]*e[5]-e[0]*t[5],o=t[1]*e[2]-e[1]*t[2],c=t[1]*e[4]-e[1]*t[4],h=t[1]*e[5]-e[1]*t[5],l=t[2]*e[3]-e[2]*t[3],y=t[3]*e[4]-e[3]*t[4],p=t[3]*e[5]-e[3]*t[5],x=h+y,d=c-l;return new u(n*o-s*s,n*d+r*o-2*s*i,n*x+r*d-i*i-2*s*a,n*p+r*x-2*i*a,r*p-a*a)}(o,c).getRoots(),l=.001*(o[0]*o[0]+2*o[1]*o[1]+o[2]*o[2]),y=.001*(c[0]*c[0]+2*c[1]*c[1]+c[2]*c[2]),p=new F("No Intersection");for(let x=0;x<h.length;x++){const t=new u(o[0],o[3]+h[x]*o[1],o[5]+h[x]*(o[4]+h[x]*o[2])).getRoots();for(let e=0;e<t.length;e++){let n=(o[0]*t[e]+o[1]*h[x]+o[3])*t[e]+(o[2]*h[x]+o[4])*h[x]+o[5];Math.abs(n)<l&&(n=(c[0]*t[e]+c[1]*h[x]+c[3])*t[e]+(c[2]*h[x]+c[4])*h[x]+c[5],Math.abs(n)<y&&p.appendPoint(new r(t[e],h[x])))}}return p.points.length>0&&(p.status="Intersection"),p}static intersectEllipseLine(t,e,n,s,r){let i;const o=new a(s.x,s.y),c=a.fromPoints(s,r),h=new a(t.x,t.y),u=o.subtract(h),l=new a(c.x/(e*e),c.y/(n*n)),y=new a(u.x/(e*e),u.y/(n*n)),p=c.dot(l),x=c.dot(y),d=x*x-p*(t=u.dot(y)-1);if(d<0)i=new F("Outside");else if(d>0){const t=Math.sqrt(d),e=(-x-t)/p,n=(-x+t)/p;(e<0||1<e)&&(n<0||1<n)?i=new F(e<0&&n<0||e>1&&n>1?"Outside":"Inside"):(i=new F("Intersection"),0<=e&&e<=1&&i.appendPoint(s.lerp(r,e)),0<=n&&n<=1&&i.appendPoint(s.lerp(r,n)))}else{const t=-x/p;0<=t&&t<=1?(i=new F("Intersection")).appendPoint(s.lerp(r,t)):i=new F("Outside")}return i}static intersectEllipsePolygon(t,e,n,s){return F.intersectEllipsePolyline(t,e,n,U(s))}static intersectEllipsePolyline(t,e,n,s){const r=new F("No Intersection"),{length:i}=s;for(let a=0;a<i-1;a++){const i=s[a],o=s[a+1],c=F.intersectEllipseLine(t,e,n,i,o);r.appendPoints(c.points)}return r.points.length>0&&(r.status="Intersection"),r}static intersectEllipseRectangle(t,e,n,s,i){const a=s.min(i),o=s.max(i),c=new r(o.x,a.y),h=new r(a.x,o.y),u=F.intersectEllipseLine(t,e,n,a,c),l=F.intersectEllipseLine(t,e,n,c,o),y=F.intersectEllipseLine(t,e,n,o,h),p=F.intersectEllipseLine(t,e,n,h,a),x=new F("No Intersection");return x.appendPoints(u.points),x.appendPoints(l.points),x.appendPoints(y.points),x.appendPoints(p.points),x.points.length>0&&(x.status="Intersection"),x}static intersectLineLine(t,e,n,s){let i;const a=(s.x-n.x)*(t.y-n.y)-(s.y-n.y)*(t.x-n.x),o=(e.x-t.x)*(t.y-n.y)-(e.y-t.y)*(t.x-n.x),c=(s.y-n.y)*(e.x-t.x)-(s.x-n.x)*(e.y-t.y);if(0!==c){const n=a/c,s=o/c;0<=n&&n<=1&&0<=s&&s<=1?(i=new F("Intersection")).points.push(new r(t.x+n*(e.x-t.x),t.y+n*(e.y-t.y))):i=new F("No Intersection")}else i=new F(0===a||0===o?"Coincident":"Parallel");return i}static intersectLinePolygon(t,e,n){return F.intersectLinePolyline(t,e,U(n))}static intersectLinePolyline(t,e,n){const s=new F("No Intersection"),{length:r}=n;for(let i=0;i<r-1;i++){const r=n[i],a=n[i+1],o=F.intersectLineLine(t,e,r,a);s.appendPoints(o.points)}return s.points.length>0&&(s.status="Intersection"),s}static intersectLineRectangle(t,e,n,s){const i=n.min(s),a=n.max(s),o=new r(a.x,i.y),c=new r(i.x,a.y),h=F.intersectLineLine(i,o,t,e),u=F.intersectLineLine(o,a,t,e),l=F.intersectLineLine(a,c,t,e),y=F.intersectLineLine(c,i,t,e),p=new F("No Intersection");return p.appendPoints(h.points),p.appendPoints(u.points),p.appendPoints(l.points),p.appendPoints(y.points),p.points.length>0&&(p.status="Intersection"),p}static intersectPolygonPolygon(t,e){return F.intersectPolylinePolyline(U(t),U(e))}static intersectPolygonPolyline(t,e){return F.intersectPolylinePolyline(U(t),e)}static intersectPolygonRectangle(t,e,n){return F.intersectPolylineRectangle(U(t),e,n)}static intersectPolylinePolyline(t,e){const n=new F("No Intersection"),{length:s}=t;for(let r=0;r<s-1;r++){const s=t[r],i=t[r+1],a=F.intersectLinePolyline(s,i,e);n.appendPoints(a.points)}return n.points.length>0&&(n.status="Intersection"),n}static intersectPolylineRectangle(t,e,n){const s=e.min(n),i=e.max(n),a=new r(i.x,s.y),o=new r(s.x,i.y),c=F.intersectLinePolyline(s,a,t),h=F.intersectLinePolyline(a,i,t),u=F.intersectLinePolyline(i,o,t),l=F.intersectLinePolyline(o,s,t),y=new F("No Intersection");return y.appendPoints(c.points),y.appendPoints(h.points),y.appendPoints(u.points),y.appendPoints(l.points),y.points.length>0&&(y.status="Intersection"),y}static intersectRectangleRectangle(t,e,n,s){const i=t.min(e),a=t.max(e),o=new r(a.x,i.y),c=new r(i.x,a.y),h=F.intersectLineRectangle(i,o,n,s),u=F.intersectLineRectangle(o,a,n,s),l=F.intersectLineRectangle(a,c,n,s),y=F.intersectLineRectangle(c,i,n,s),p=new F("No Intersection");return p.appendPoints(h.points),p.appendPoints(u.points),p.appendPoints(l.points),p.appendPoints(y.points),p.points.length>0&&(p.status="Intersection"),p}static intersectRayRay(t,e,n,s){let i;const a=(s.x-n.x)*(t.y-n.y)-(s.y-n.y)*(t.x-n.x),o=(e.x-t.x)*(t.y-n.y)-(e.y-t.y)*(t.x-n.x),c=(s.y-n.y)*(e.x-t.x)-(s.x-n.x)*(e.y-t.y);if(0!==c){const n=a/c;(i=new F("Intersection")).points.push(new r(t.x+n*(e.x-t.x),t.y+n*(e.y-t.y)))}else i=new F(0===a||0===o?"Coincident":"Parallel");return i}appendPoint(t){this.points.push(t)}appendPoints(t){this.points=this.points.concat(t)}}var Q=F;const G={pointInCircle:function(t,e,n){return a.fromPoints(e,t).length()<=n},pointInEllipse:function(t,e,n,s){const r=t.subtract(e);return r.x*r.x/(n*n)+r.y*r.y/(s*s)<=1},pointInPolyline:function(t,e){const{length:n}=e;let s,r=0,i=e[0];for(let a=1;a<=n;a++){const o=e[a%n],c=Math.min(i.y,o.y),h=Math.max(i.y,o.y),u=Math.max(i.x,o.x);i.y!==o.y&&c<t.y&&t.y<=h&&t.x<=u&&(s=(t.y-i.y)*(o.x-i.x)/(o.y-i.y)+i.x,(i.x===o.x||t.x<=s)&&r++),i=o}return r%2===1}};G.pointInPolygon=G.pointInPolyline,G.pointInRectangle=function(t,e,n){return e.x<=t.x&&t.x<n.x&&e.y<=t.y&&t.y<n.y};n.d(e,"a",function(){return V}),n.d(e,"d",function(){return Z}),n.d(e,"e",function(){return H}),n.d(e,"b",function(){return W}),n.d(e,"c",function(){return J});var V=function(t,e){return Q.intersect(t,e).points},Z=function(t){return O.quadraticBezier(t.src,t.c1,t.dst)},H=function(t){return O.rectangle({top:t.x,left:t.y,width:t.width,height:t.height})},W=function(t){return O.ellipse(t.center.x,t.center.y,t.rx,t.ry)},J=function(t){return O.line(t.src,t.dst)}},g2Zv:function(t,e,n){"use strict";var s=n("Sxkx");e.a=function(t){return t&&Object(s.c)(t.x)&&Object(s.c)(t.y)}},hCWT:function(t,e,n){"use strict";var s=n("1Ldg");e.a=s.a},lpvu:function(t,e,n){"use strict";var s=n("2Fjn"),r=n("mXGw"),i=n.n(r),a=n("obYp"),o=n("Rbzu"),c=function(t){return"[object Object]"===Object.prototype.toString.call(t)},h=function(t){return function(e){return Object(o.a)({},e,t(e))}},u=function(t){var e=function(t){var e=t.src,n=t.dst;return{src:c(e)?e:{id:e},dst:c(n)?n:{id:n}}}(t),n=e.src,s=e.dst;return n!==t.src||s!==t.dst?Object(o.a)({},t,{src:n,dst:s}):t},l=h(function(t){var e=t.connections;return{connections:Object(r.useMemo)(function(){return e.map(u)},[e])}}),y=n("2xrT"),p=n.n(y),x=p.a,d=function(t){return t.replace(/\s/g,"")},m=function(t){return t.id||"(".concat(t.x,",").concat(t.y,")")},f=function(t,e){var n=d(function(t){var e=t.src,n=t.dst;return"".concat(m(e),"->").concat(m(n))}(t)),s=Object(o.a)({},t,{id:n});return(e[n]=e[n]||[]).push(s),s},b=function(t){return t.length>1},g=h(function(t){var e=t.connections;return{connections:Object(r.useMemo)(function(){var t={},n=e.map(function(t){return function(e){return e.id?e:f(e,t)}}(t));return function(t){x(t).filter(b).forEach(function(t){t.forEach(function(t,e){t.id="".concat(e+1,".").concat(t.id)})})}(t),n},[e])}}),w=n("pL2a"),v=n.n(w),P=n("1qCV"),E=n.n(P),M=n("K4BZ"),k=(E.a,p.a,v.a,function(){for(var t=arguments.length,e=new Array(t),n=0;n<t;n++)e[n]=arguments[n];return function(t){return e.reduce(function(t,e){return e(t)},t)}}),A=function(t){return t.id||"(".concat(t.x,",").concat(t.y,")")},R=function(t){return t.reduce(function(t,e){var n,s=[(n=e).src,n.dst].map(A).sort().join("<->");return(t[s]=t[s]||[]).push(e),t},{})},T=function(t){return t.length>1},I=function(t){return p()(t).filter(T)},_=function(t){return function(e){return e.reduce(function(e,n){var s=function(t,e){var n=(t.length-1)*e;return n-n/2}(n,t),r=A(n[0].src),i=function(t){return A(t.src)!==r},a=function(e){return s-t*e};return n.forEach(function(t,n){e[t.id]=Object(o.a)({},t,{bend:i(t)?-a(n):a(n)})}),e},{})}},X=function(t){return function(e){return t.map(function(t){return e[t.id]||t})}},$=function(t,e){var n=function(t){var e=t.box,n=t.x,s=t.y,r=t.width,i=t.height;return e||n&&s&&{x:n,y:s,width:r,height:i}}(e);return n&&(t[e.id]=n),t},N=h(function(t){var e=t.nodes,n=t.boxes,s=Object(r.useMemo)(function(){return function(t){return t.reduce($,{})}(e)},[e]);return{boxes:Object(r.useMemo)(function(){return Object(o.a)({},s,n)},[s,n])}}),Y=n("FBSb"),C=n("s20r"),L=n.n(C);var O=n("8ET1"),S=n.n(O),j=n("7X5e"),D=n.n(j);function B(t){return function(t){if(L()(t)){for(var e=0,n=new Array(t.length);e<t.length;e++)n[e]=t[e];return n}}(t)||function(t){if(D()(Object(t))||"[object Arguments]"===Object.prototype.toString.call(t))return S()(t)}(t)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance")}()}var z=function(t){return t.y},q=function(t){return t.x+t.width},U=function(t){return t.y+t.height},F=function(t){return t.x},Q=function(t){return function(e){return t.apply(void 0,B(e))}},G=Q(Math.min),V=Q(Math.max),Z=p.a,H={x:0,y:0,width:0,height:0},W=function(t){return Object(M.a)(t)?t:Object(o.a)({},H,t)},J=function(t){var e=Z(t).map(W);return Object(Y.a)(e)?{width:0,height:0}:function(t){return e=G(t.map(z)),n=V(t.map(q)),s=V(t.map(U)),{x:r=G(t.map(F)),y:e,width:n-r,height:s-e};var e,n,s,r}(e)},K=function(t,e){return Object(r.useMemo)(function(){var n=[q(t),U(t)],s=n[0],r=n[1],i=function(t,e){return"function"===typeof e?e(t):c(e)?e:{right:t.x,bottom:t.y}}(t,e);return{width:s+i.right,height:r+i.bottom}},[t,e])},tt=n("1VIh"),et=n("CcWs"),nt=i.a.createElement;e.a=function(t){var e,n=t.viewportPadding,i=t.layout,o=void 0===i?Object(tt.a)(et.a):i,c=Object(s.a)(t,["viewportPadding","layout"]),u=k(l,g,function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:12;return h(function(e){var n=e.connections;return{connections:k(R,I,_(t),X(n))(n)}})}(),N,function(t){return function(e){return Object(r.useMemo)(function(){return t(e)},t.deps(e))}}(o),(e=n,h(function(t){var n=t.boxes,s=Object(r.useMemo)(function(){return J(n)},[n]);return K(s,e)})))(c);return nt(a.a,u)}},md7T:function(t,e,n){n("6JBb"),t.exports=n("TaGV").Object.values},oGUj:function(t,e,n){"use strict";n.r(e);var s=n("z3IF"),r=n("2Fjn"),i=n("mXGw"),a=n.n(i),o=n("SAVP"),c=n("qImK"),h=n("lpvu"),u=n("8foj"),l=a.a.createElement,y=function(t){var e=t.box;return l("rect",e)};n.d(e,"default",function(){return f});a.a.createElement;var p={},x="wrapper",d=Object(o.a)("h1",null,"Basic Graph"),m=Object(o.a)(c.a,{code:"import React from 'react';\nimport { Graph } from '@regraph/graph';\nimport { Line } from '@regraph/connections';\n\nconst Rect = ({ box }) => <rect {...box} />;\n\nexport default () => (\n  <Graph\n    node={{ type: Rect }}\n    nodes={[\n      { id: 'ping', box: { x: 50, y: 40, width: 20, height: 20 } },\n      { id: 'pong', box: { x: 150, y: 40, width: 20, height: 20 } },\n    ]}\n    connections={[\n      {\n        type: Line,\n        src: 'ping',\n        dst: 'pong',\n      },\n    ]}\n  />\n);\n",output:Object(o.a)(function(){return l(h.a,{node:{type:y},nodes:[{id:"ping",box:{x:50,y:40,width:20,height:20}},{id:"pong",box:{x:150,y:40,width:20,height:20}}],connections:[{type:u.a,src:"ping",dst:"pong"}]})},{mdxType:"Graph"}),path:"examples/basic-graph/index.jsx",sourceOpen:!0,mdxType:"Example"});function f(t){var e=t.components,n=Object(r.a)(t,["components"]);return Object(o.a)(x,Object(s.a)({},p,n,{components:e,mdxType:"MDXLayout"}),d,m)}f.isMDXComponent=!0},pL2a:function(t,e,n){t.exports=n("AXMb")}},[["5dM6",1,0]]]);